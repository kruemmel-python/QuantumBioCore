
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Full Documentation Report: CipherCore_OpenCl.dll</title>
      <style>
    :root { --sidebar-width: 300px; }
    html { scroll-behavior: smooth; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #111827; color: #d1d5db; line-height: 1.6; margin: 0; }
    .report-container { display: flex; }
    .sidebar { width: var(--sidebar-width); height: 100vh; position: sticky; top: 0; background-color: #1f2937; border-right: 1px solid #374151; padding: 1.5rem; overflow-y: auto; }
    .sidebar h1 { font-size: 1.5rem; color: #fff; margin-top: 0; }
    .sidebar h2 { font-size: 0.75rem; color: #9ca3af; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 1.5rem; border-bottom: 1px solid #4b5563; padding-bottom: 0.5rem; }
    .sidebar ul { list-style: none; padding: 0; margin: 0.5rem 0; }
    .sidebar li a { color: #d1d5db; text-decoration: none; display: block; padding: 0.4rem 0.5rem; border-radius: 4px; font-size: 0.875rem; }
    .sidebar li a:hover { background-color: #374151; color: #fff; }
    .content { flex-grow: 1; padding: 2rem 3rem; max-width: calc(100% - var(--sidebar-width)); }
    .content h1 { font-size: 2.5rem; margin-top: 0; }
    .content section { border-bottom: 1px solid #4b5563; padding-bottom: 2rem; margin-bottom: 2rem; }
    .content section:last-child { border-bottom: none; }
    h2, h3 { color: #ffffff; border-bottom: 1px solid #4b5563; padding-bottom: 0.5rem; }
    h2 { font-size: 2.25rem; }
    h3 { font-size: 1.5rem; margin-top: 2rem; }
    code { background-color: #374151; padding: 0.2em 0.4em; margin: 0; font-size: 85%; border-radius: 3px; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
    .metadata { display: flex; flex-wrap: wrap; gap: 1rem; color: #9ca3af; margin: 1rem 0 2rem 0; }
    table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
    th, td { text-align: left; padding: 0.75rem; border-top: 1px solid #374151; }
    th { color: #9ca3af; font-weight: 600; }
    pre { background-color: #111827; padding: 1rem; border-radius: 5px; overflow-x: auto; border: 1px solid #374151; }
    .prose { white-space: pre-wrap; }
  </style>
    </head>
    <body>
      <div class="report-container">
        
    <nav class="sidebar">
      <h1>Function Index</h1>
      
        <div>
          <h2>init</h2>
          <ul>
            
              <li><a href="#initialize_gpu">initialize_gpu</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>kernel.bio</h2>
          <ul>
            
              <li><a href="#execute_dynamic_token_assignment_gpu">execute_dynamic_token_assignment_gpu</a></li>
            
              <li><a href="#execute_hebbian_update_on_gpu">execute_hebbian_update_on_gpu</a></li>
            
              <li><a href="#execute_proto_segmented_sum_gpu">execute_proto_segmented_sum_gpu</a></li>
            
              <li><a href="#execute_proto_update_step_gpu">execute_proto_update_step_gpu</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>kernel.embedding</h2>
          <ul>
            
              <li><a href="#execute_embedding_backward_gpu">execute_embedding_backward_gpu</a></li>
            
              <li><a href="#execute_embedding_lookup_gpu">execute_embedding_lookup_gpu</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>kernel.layernorm</h2>
          <ul>
            
              <li><a href="#execute_layernorm_backward_on_gpu">execute_layernorm_backward_on_gpu</a></li>
            
              <li><a href="#execute_layernorm_on_gpu">execute_layernorm_on_gpu</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>kernel.loss</h2>
          <ul>
            
              <li><a href="#execute_cross_entropy_loss_grad_gpu">execute_cross_entropy_loss_grad_gpu</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>kernel.matmul</h2>
          <ul>
            
              <li><a href="#execute_matmul_backward_on_gpu">execute_matmul_backward_on_gpu</a></li>
            
              <li><a href="#execute_matmul_batched_backward_on_gpu">execute_matmul_batched_backward_on_gpu</a></li>
            
              <li><a href="#execute_matmul_batched_on_gpu">execute_matmul_batched_on_gpu</a></li>
            
              <li><a href="#execute_matmul_on_gpu">execute_matmul_on_gpu</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>kernel.misc</h2>
          <ul>
            
              <li><a href="#execute_add_bias_on_gpu">execute_add_bias_on_gpu</a></li>
            
              <li><a href="#execute_add_broadcast_pe_gpu">execute_add_broadcast_pe_gpu</a></li>
            
              <li><a href="#execute_add_on_gpu">execute_add_on_gpu</a></li>
            
              <li><a href="#execute_broadcast_add_gpu">execute_broadcast_add_gpu</a></li>
            
              <li><a href="#execute_gelu_backward_on_gpu">execute_gelu_backward_on_gpu</a></li>
            
              <li><a href="#execute_gelu_on_gpu">execute_gelu_on_gpu</a></li>
            
              <li><a href="#execute_mul_backward_on_gpu">execute_mul_backward_on_gpu</a></li>
            
              <li><a href="#execute_mul_on_gpu">execute_mul_on_gpu</a></li>
            
              <li><a href="#execute_pairwise_similarity_gpu">execute_pairwise_similarity_gpu</a></li>
            
              <li><a href="#execute_qml_classifier_gpu">execute_qml_classifier_gpu</a></li>
            
              <li><a href="#execute_reduce_sum_gpu">execute_reduce_sum_gpu</a></li>
            
              <li><a href="#execute_shape_loss_with_reward_penalty_gpu">execute_shape_loss_with_reward_penalty_gpu</a></li>
            
              <li><a href="#execute_shape_loss_with_reward_penalty_list_gpu">execute_shape_loss_with_reward_penalty_list_gpu</a></li>
            
              <li><a href="#execute_threshold_spike_on_gpu">execute_threshold_spike_on_gpu</a></li>
            
              <li><a href="#execute_transpose_12_batched_gpu">execute_transpose_12_batched_gpu</a></li>
            
              <li><a href="#execute_transpose_backward_on_gpu">execute_transpose_backward_on_gpu</a></li>
            
              <li><a href="#execute_transpose_batched_gpu">execute_transpose_batched_gpu</a></li>
            
              <li><a href="#execute_transpose_on_gpu">execute_transpose_on_gpu</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>kernel.optimizer</h2>
          <ul>
            
              <li><a href="#execute_adam_update_on_gpu">execute_adam_update_on_gpu</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>kernel.quantum</h2>
          <ul>
            
              <li><a href="#execute_grover_gpu">execute_grover_gpu</a></li>
            
              <li><a href="#execute_hhl_gpu">execute_hhl_gpu</a></li>
            
              <li><a href="#execute_qaoa_gpu">execute_qaoa_gpu</a></li>
            
              <li><a href="#execute_qec_cycle_gpu">execute_qec_cycle_gpu</a></li>
            
              <li><a href="#execute_shor_gpu">execute_shor_gpu</a></li>
            
              <li><a href="#execute_vqe_gpu">execute_vqe_gpu</a></li>
            
              <li><a href="#quantum_apply_gate_sequence">quantum_apply_gate_sequence</a></li>
            
              <li><a href="#quantum_export_to_qasm">quantum_export_to_qasm</a></li>
            
              <li><a href="#quantum_upload_gate_sequence">quantum_upload_gate_sequence</a></li>
            
              <li><a href="#subqg_initialize_state">subqg_initialize_state</a></li>
            
              <li><a href="#subqg_initialize_state_batched">subqg_initialize_state_batched</a></li>
            
              <li><a href="#subqg_inject_agents">subqg_inject_agents</a></li>
            
              <li><a href="#subqg_release_state">subqg_release_state</a></li>
            
              <li><a href="#subqg_set_deterministic_mode">subqg_set_deterministic_mode</a></li>
            
              <li><a href="#subqg_simulation_step">subqg_simulation_step</a></li>
            
              <li><a href="#subqg_simulation_step_batched">subqg_simulation_step_batched</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>kernel.softmax</h2>
          <ul>
            
              <li><a href="#execute_log_softmax_stable_gpu">execute_log_softmax_stable_gpu</a></li>
            
              <li><a href="#execute_softmax_backward_on_gpu">execute_softmax_backward_on_gpu</a></li>
            
              <li><a href="#execute_softmax_on_gpu">execute_softmax_on_gpu</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>lifecycle</h2>
          <ul>
            
              <li><a href="#finish_gpu">finish_gpu</a></li>
            
              <li><a href="#shutdown_gpu">shutdown_gpu</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>memory</h2>
          <ul>
            
              <li><a href="#free_gpu_memory">free_gpu_memory</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>metrics</h2>
          <ul>
            
              <li><a href="#get_last_kernel_metrics">get_last_kernel_metrics</a></li>
            
              <li><a href="#register_kernel_measurement_buffers">register_kernel_measurement_buffers</a></li>
            
              <li><a href="#reset_kernel_measurement_buffers">reset_kernel_measurement_buffers</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>misc</h2>
          <ul>
            
              <li><a href="#simulated_kernel_free">simulated_kernel_free</a></li>
            
              <li><a href="#simulated_kernel_write">simulated_kernel_write</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>noisectrl</h2>
          <ul>
            
              <li><a href="#get_noise_level">get_noise_level</a></li>
            
              <li><a href="#set_noise_level">set_noise_level</a></li>
            
          </ul>
        </div>
      
        <div>
          <h2>transfer</h2>
          <ul>
            
              <li><a href="#execute_clone_on_gpu">execute_clone_on_gpu</a></li>
            
              <li><a href="#read_gpu_to_host_blocking">read_gpu_to_host_blocking</a></li>
            
              <li><a href="#write_host_to_gpu_blocking">write_host_to_gpu_blocking</a></li>
            
          </ul>
        </div>
      
    </nav>
  
        
    <main class="content">
      <h1>CipherCore_OpenCl.dll Documentation Report</h1>
      
      <section id="execute_adam_update_on_gpu">
        <h2>execute_adam_update_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.optimizer</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>param_buffer</code></td></tr><tr><td><code>void*</code></td><td><code>grad_buffer</code></td></tr><tr><td><code>void*</code></td><td><code>m_buffer</code></td></tr><tr><td><code>void*</code></td><td><code>v_buffer</code></td></tr><tr><td><code>int</code></td><td><code>num_elements</code></td></tr><tr><td><code>int</code></td><td><code>t</code></td></tr><tr><td><code>float</code></td><td><code>lr</code></td></tr><tr><td><code>float</code></td><td><code>beta1</code></td></tr><tr><td><code>float</code></td><td><code>beta2</code></td></tr><tr><td><code>float</code></td><td><code>eps</code></td></tr><tr><td><code>float</code></td><td><code>weight_decay</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">Absolut. Hier ist die Dokumentation für `execute_adam_update_on_gpu`, verfasst für C/Python-Entwickler.<br /><br />---<br /><br />### `execute_adam_update_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt einen einzelnen Optimierungsschritt des Adam-Algorithmus (Adaptive Moment Estimation) auf der angegebenen GPU aus. Diese Funktion aktualisiert einen Parameter-Puffer basierend auf seinem Gradienten unter Verwendung von Schätzungen des ersten und zweiten Moments (`m` und `v`). Dies ist ein Standardverfahren zum Trainieren von neuronalen Netzen und anderen Machine-Learning-Modellen.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzungen:** Der OpenCL-Kontext muss initialisiert und alle Puffer müssen bereits auf der GPU alloziert sein (`cl_mem` Objekte). Der `gpu_index` muss einem gültigen, initialisierten Gerät entsprechen.<br />*   **Puffergrößen:** Die Puffer `param_buffer`, `grad_buffer`, `m_buffer` und `v_buffer` müssen die gleiche Größe haben und mindestens `num_elements * sizeof(float)` Bytes umfassen.<br />*   **Zustandsbehaftete Puffer:** `m_buffer` und `v_buffer` speichern den Zustand des Optimierers. Sie müssen über aufeinanderfolgende Trainingsschritte für dieselben Parameter persistent gehalten werden.<br />*   **Zeitschritt `t`:** Der Parameter `t` ist der globale Update-Zähler, der typischerweise bei 1 beginnt und bei jedem Aufruf inkrementiert wird. Er wird für die Bias-Korrektur im Adam-Algorithmus benötigt.<br />*   **Fehlercodes:** Die Funktion gibt `0` bei Erfolg oder einen negativen Fehlercode im Fehlerfall zurück (z.B. bei ungültigen Puffern oder einem OpenCL-Kernel-Fehlschlag).<br /><br />#### Python (ctypes) Anbindung<br /><br />Ein Python `ctypes`-Beispiel zeigt die Anbindung der Funktion. Ersetzen Sie in diesem Snippet die Platzhalter für die Buffer-Pointer (z.B. `param_ptr`, `grad_ptr`, `m_ptr`, `v_ptr`) durch die tatsächlichen `ctypes`-Pointer oder `cl_mem`-Handles Ihrer auf der GPU allozierten Puffer. Passen Sie außerdem `num_elements` und die Adam-Hyperparameter an Ihre Konfiguration an.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_adam_update_on_gpu(int gpu_index, void* param_buffer, void* grad_buffer, void* m_buffer, void* v_buffer, int num_elements, int t, float lr, float beta1, float beta2, float eps, float weight_decay);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_adam_update_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_adam_update_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_void_p, c_int, c_int, c_float, c_float, c_float, c_float, c_float]
lib.execute_adam_update_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_adam_update_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)

print(f"Call to 'execute_adam_update_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_add_bias_on_gpu">
        <h2>execute_add_bias_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_a_or_c</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_b_bias</code></td></tr><tr><td><code>int</code></td><td><code>M</code></td></tr><tr><td><code>int</code></td><td><code>N</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_add_bias_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt eine elementweise Addition eines Bias-Vektors zu jeder Zeile einer Matrix direkt auf dem angegebenen GPU-Gerät aus. Die Operation ist "in-place", was bedeutet, dass der Eingabepuffer `buffer_a_or_c` direkt mit dem Ergebnis überschrieben wird. Diese Funktion wird typischerweise in neuronalen Netzen nach einer Faltungs- oder Matrixmultiplikations-Operation eingesetzt, um einen Bias-Term hinzuzufügen.<br /><br />#### Anwendungshinweise<br /><br />*   Die OpenCL-Umgebung muss für den angegebenen `gpu_index` bereits initialisiert sein.<br />*   Die Puffer `buffer_a_or_c` und `buffer_b_bias` müssen zuvor auf der GPU alloziert worden sein (z.B. mit `create_buffer_on_gpu`).<br />*   `buffer_a_or_c` muss die Größe für eine `M x N`-Matrix haben (`M * N` Elemente). `buffer_b_bias` muss als Vektor der Länge `N` alloziert sein.<br />*   Die Operation modifiziert `buffer_a_or_c` direkt. Es wird kein neuer Ausgabepuffer erstellt.<br />*   Die Funktion gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehlercode (z.B. ungültiger GPU-Index, OpenCL-Fehler).<br /><br />#### Hinweis zur Einbindung (Python/ctypes)<br /><br />In einem Python-Aufruf mittels `ctypes` müssen die `void*` Argumente (`buffer_a_or_c`, `buffer_b_bias`) als `ctypes.c_void_p` übergeben werden, welche die von der Puffer-Erstellungsfunktion zurückgegebenen Handles enthalten. Die Integer-Werte `M` und `N` müssen den Dimensionen der Matrix entsprechen, auf der die Operation ausgeführt wird.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_add_bias_on_gpu(int gpu_index, void* buffer_a_or_c, void* buffer_b_bias, int M, int N);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_add_bias_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_add_bias_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int, c_int]
lib.execute_add_bias_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_add_bias_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0)

print(f"Call to 'execute_add_bias_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_add_broadcast_pe_gpu">
        <h2>execute_add_broadcast_pe_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>input</code></td></tr><tr><td><code>void*</code></td><td><code>pe_slice</code></td></tr><tr><td><code>void*</code></td><td><code>output</code></td></tr><tr><td><code>int</code></td><td><code>B</code></td></tr><tr><td><code>int</code></td><td><code>S</code></td></tr><tr><td><code>int</code></td><td><code>E</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_add_broadcast_pe_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt eine elementweise Addition mit Broadcasting auf der GPU aus. Ein 1D-Vektor (`pe_slice`) der Länge `E` wird zu jedem `E`-dimensionalen Vektor innerhalb des 3D-Eingabetensors (`input`) addiert. Diese Operation wird typischerweise verwendet, um Prototypen- oder Positionsembeddings zu einem Batch von Sequenzdaten hinzuzufügen.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzungen:** Der GPU-Kontext muss mit `initialize_gpu` für den angegebenen `gpu_index` initialisiert sein.<br />*   **Puffer (Buffers):** Die Zeiger `input`, `pe_slice` und `output` müssen auf gültige, vorab auf der GPU zugewiesene Puffer verweisen. Die Operation kann "in-place" ausgeführt werden, indem für `input` und `output` derselbe Pufferzeiger übergeben wird.<br />*   **Puffergrößen:** Die Größe der Puffer muss den Dimensionen entsprechen: `input` und `output` benötigen `B * S * E` Elemente, während `pe_slice` `E` Elemente benötigt. Alle Puffer sollten denselben Datentyp verwenden (typischerweise 32-Bit-Gleitkommazahlen).<br />*   **Dimensionen:** `B`, `S` und `E` müssen positive Ganzzahlen sein, die die Form des Tensors (`Batch`, `Sequenzlänge`, `Embedding-Größe`) definieren.<br />*   **Rückgabewert:** Gibt `0` bei Erfolg zurück, andernfalls einen Fehlercode.<br /><br />#### Python `ctypes` Integration<br /><br />Im Python `ctypes`-Wrapper müssen die Funktionssignatur (`argtypes`, `restype`) definiert und die Platzhalter für die Pufferzeiger (`c_void_p`) sowie die Dimensionsparameter `B`, `S` und `E` durch die entsprechenden Variablen ersetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_add_broadcast_pe_gpu(int gpu_index, void* input, void* pe_slice, void* output, int B, int S, int E);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_add_broadcast_pe_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_add_broadcast_pe_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int]
lib.execute_add_broadcast_pe_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_add_broadcast_pe_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0)

print(f"Call to 'execute_add_broadcast_pe_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_add_on_gpu">
        <h2>execute_add_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_a</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_b</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_c</code></td></tr><tr><td><code>int</code></td><td><code>num_elements</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_add_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt eine elementweise Vektoraddition (`C = A + B`) auf einem spezifizierten GPU-Gerät aus. Diese Funktion ist für die Beschleunigung rechenintensiver Additionen großer Datenmengen konzipiert, indem sie die parallele Verarbeitungsleistung von OpenCL nutzt. Das Ergebnis wird direkt in den dafür vorgesehenen Ausgabepuffer geschrieben.<br /><br />#### Anwendungshinweise<br /><br />*   Alle drei Puffer (`buffer_a`, `buffer_b`, `buffer_c`) müssen vom Aufrufer vorab mit der erforderlichen Größe allokiert werden.<br />*   Die Größe jedes Puffers muss mindestens `num_elements * sizeof(datentyp)` betragen. Der Aufrufer ist für die korrekte und konsistente Typisierung der Pufferdaten (z.B. `float` oder `int`) verantwortlich.<br />*   Der `gpu_index` ist ein nullbasierter Index, der ein verfügbares OpenCL-Gerät auswählt.<br />*   Die Ausführung ist synchron. Die Funktion blockiert, bis die GPU-Berechnung abgeschlossen ist und die Ergebnisse in `buffer_c` geschrieben wurden.<br />*   Die Funktion gibt `0` bei Erfolg und einen negativen Fehlercode bei einem Fehler zurück (z.B. ungültiger GPU-Index, Fehler bei der Puffererstellung).<br /><br />#### Hinweis zur Ctypes-Nutzung<br /><br />Ersetzen Sie in Ihrem Python-`ctypes`-Aufruf die Platzhalter durch die entsprechenden Zeiger auf Ihre Datenpuffer (z.B. über `numpy.ctypeslib.as_ctypes`) sowie die korrekte Anzahl der Elemente.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_add_on_gpu(int gpu_index, void* buffer_a, void* buffer_b, void* buffer_c, int num_elements);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_add_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_add_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int]
lib.execute_add_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_add_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_add_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_broadcast_add_gpu">
        <h2>execute_broadcast_add_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>a</code></td></tr><tr><td><code>void*</code></td><td><code>b</code></td></tr><tr><td><code>void*</code></td><td><code>c</code></td></tr><tr><td><code>int</code></td><td><code>B</code></td></tr><tr><td><code>int</code></td><td><code>M</code></td></tr><tr><td><code>int</code></td><td><code>N</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_broadcast_add_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt eine GPU-beschleunigte Broadcast-Addition aus: `c = a + broadcast(b)`. Dabei wird der Tensor `b` entlang der `M`-Dimension "gestreckt", um den Dimensionen des Tensors `a` zu entsprechen. Diese Operation ist fundamental, beispielsweise um einen Bias-Vektor zu einer Batch von Feature-Maps hinzuzufügen.<br /><br />#### Anwendungshinweise<br /><br />*   Die Ziel-GPU (`gpu_index`) muss zuvor mit `initialize_gpu` initialisiert worden sein.<br />*   Alle Puffer (`a`, `b`, `c`) müssen bereits auf der GPU alloziert sein und denselben Datentyp (typischerweise `float`) haben.<br />*   Die Puffer `a` und `c` müssen eine Größe von `B * M * N` Elementen haben.<br />*   Der Puffer `b` muss eine Größe von `B * N` Elementen haben, da er über die `M`-Dimension gebroadcastet wird.<br />*   Die Funktion gibt `0` bei Erfolg und einen negativen Fehlercode bei einem Problem zurück (z. B. ungültiger `gpu_index` oder OpenCL-Fehler).<br />*   Der Aufrufer ist für die Verwaltung und Freigabe der GPU-Puffer `a`, `b` und `c` verantwortlich.<br /><br />#### Python `ctypes` Integration<br /><br />Um diese Funktion über `ctypes` in Python aufzurufen, ersetzen Sie die Platzhalter im entsprechenden Code-Snippet. Übergeben Sie die Pointer auf Ihre GPU-Datenpuffer für `a`, `b` und `c` sowie die Integer-Werte für die Dimensionen `B`, `M` und `N`.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_broadcast_add_gpu(int gpu_index, void* a, void* b, void* c, int B, int M, int N);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_broadcast_add_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_broadcast_add_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int]
lib.execute_broadcast_add_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_broadcast_add_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0)

print(f"Call to 'execute_broadcast_add_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_clone_on_gpu">
        <h2>execute_clone_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>transfer</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>src_buffer</code></td></tr><tr><td><code>void*</code></td><td><code>dst_buffer</code></td></tr><tr><td><code>size_t</code></td><td><code>size</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_clone_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Kopiert einen Datenblock von einem Quellpuffer in einen Zielpuffer direkt auf dem angegebenen GPU-Gerät. Diese Operation ist hoch-effizient, da sie einen Datentransfer über den Host (CPU) vermeidet. Sie wird typischerweise verwendet, um Zustände zu duplizieren oder Daten für parallele Berechnungen vorzubereiten, ohne die Host-GPU-Busbandbreite zu belasten.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzungen:** Beide Puffer (`src_buffer`, `dst_buffer`) müssen bereits auf der Ziel-GPU mit `allocate_buffer_on_gpu` oder einer ähnlichen Funktion allokiert worden sein.<br />*   **Puffergrößen:** Der Zielpuffer (`dst_buffer`) muss mindestens `size` Bytes groß sein, um einen Speicherüberlauf zu verhindern.<br />*   **Synchronität:** Der Aufruf ist blockierend. Die Funktion kehrt erst zurück, nachdem der Kopiervorgang auf der GPU abgeschlossen ist.<br />*   **Kontext:** Ein gültiger `gpu_index` muss angegeben werden, der einem initialisierten Gerät entspricht.<br />*   **Fehlercodes:** Gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehler, z. B. ungültige Puffer-Handles oder einen ungültigen `gpu_index`.<br /><br />#### Python `ctypes` Beispiel<br /><br />Im folgenden `ctypes`-Beispiel müssen die Zeiger `src_gpu_buffer_ptr` und `dst_gpu_buffer_ptr` (erhalten von `allocate_buffer_on_gpu`) sowie die zu kopierende Größe `buffer_size_in_bytes` durch tatsächliche Werte ersetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_clone_on_gpu(int gpu_index, void* src_buffer, void* dst_buffer, size_t size);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_clone_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_clone_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_size_t]
lib.execute_clone_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_clone_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_clone_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_cross_entropy_loss_grad_gpu">
        <h2>execute_cross_entropy_loss_grad_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.loss</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>log_probs</code></td></tr><tr><td><code>void*</code></td><td><code>target_indices</code></td></tr><tr><td><code>void*</code></td><td><code>grad_input</code></td></tr><tr><td><code>void*</code></td><td><code>loss_per_sample</code></td></tr><tr><td><code>int</code></td><td><code>num_rows</code></td></tr><tr><td><code>int</code></td><td><code>V</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### **execute_cross_entropy_loss_grad_gpu**<br /><br />#### **Beschreibung**<br /><br />Berechnet den Gradienten der Cross-Entropy-Verlustfunktion auf der GPU. Diese Funktion ist ein Kernbestandteil der Backpropagation für Klassifikationsmodelle. Sie verwendet die Log-Wahrscheinlichkeiten (Modellausgabe) und die Zielindizes, um den Eingabegradienten (`grad_input`) und den Verlust pro Datenpunkt (`loss_per_sample`) zu berechnen.<br /><br />#### **Anwendungshinweise**<br /><br />*   Alle `void*`-Pointer (`log_probs`, `target_indices`, `grad_input`, `loss_per_sample`) müssen auf gültige, auf dem Ziel-GPU (`gpu_index`) zugewiesene Speicherpuffer zeigen.<br />*   Die Puffer müssen die korrekten Größen haben:<br />    *   `log_probs` (Eingabe): `num_rows * V * sizeof(float)`<br />    *   `target_indices` (Eingabe): `num_rows * sizeof(int)`<br />    *   `grad_input` (Ausgabe): `num_rows * V * sizeof(float)`<br />    *   `loss_per_sample` (Ausgabe): `num_rows * sizeof(float)`<br />*   Die Ausführung ist synchron; die Funktion blockiert, bis die GPU-Berechnung abgeschlossen ist.<br />*   Ein Rückgabewert von `0` signalisiert Erfolg, während ein negativer Wert einen Fehlercode darstellt.<br /><br />#### **Python `ctypes`-Integration**<br /><br />In einem Python `ctypes`-Wrapper müssen die `void*`-Argumente durch die entsprechenden Pointer-Objekte ersetzt werden, die auf die GPU-Puffer verweisen. Passen Sie die Dimensionsparameter `num_rows` und `V` entsprechend der Form Ihrer Daten an.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_cross_entropy_loss_grad_gpu(int gpu_index, void* log_probs, void* target_indices, void* grad_input, void* loss_per_sample, int num_rows, int V);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_cross_entropy_loss_grad_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_cross_entropy_loss_grad_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_void_p, c_int, c_int]
lib.execute_cross_entropy_loss_grad_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_cross_entropy_loss_grad_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0)

print(f"Call to 'execute_cross_entropy_loss_grad_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_dynamic_token_assignment_gpu">
        <h2>execute_dynamic_token_assignment_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.bio</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>activations_bse</code></td></tr><tr><td><code>void*</code></td><td><code>prototypes_te</code></td></tr><tr><td><code>void*</code></td><td><code>output_indices_bs</code></td></tr><tr><td><code>int</code></td><td><code>B</code></td></tr><tr><td><code>int</code></td><td><code>S</code></td></tr><tr><td><code>int</code></td><td><code>E</code></td></tr><tr><td><code>int</code></td><td><code>T</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_dynamic_token_assignment_gpu`<br /><br />#### Beschreibung<br /><br />Diese Funktion führt eine Nearest-Neighbor-Suche auf der GPU durch. Für jeden Aktivierungsvektor (`activations_bse`) findet sie den Vektor im Prototypen-Set (`prototypes_te`), der die geringste euklidische Distanz aufweist. Der Index des am besten passenden Prototyps wird in den Ausgabepuffer (`output_indices_bs`) geschrieben. Diese Operation ist fundamental für Vektorquantisierungs-Schritte in KI-Modellen.<br /><br />#### Anwendungshinweise<br /><br />-   **Voraussetzungen:** Die GPU muss zuvor mit `initialize_gpu` initialisiert worden sein. Alle `void*` Buffer müssen bereits auf dem GPU-Speicher allokiert sein.<br />-   **Puffergrößen:** Die Größe der Buffer muss exakt den Dimensionen entsprechen:<br />    -   `activations_bse`: `B * S * E * sizeof(float)`<br />    -   `prototypes_te`: `T * E * sizeof(float)`<br />    -   `output_indices_bs`: `B * S * sizeof(int)`<br />-   **Datenfluss:** Die Daten für `activations_bse` und `prototypes_te` müssen vor diesem Aufruf auf die GPU geschrieben werden. Die Ergebnisse in `output_indices_bs` müssen nach dem Aufruf von der GPU zurückgelesen werden.<br />-   **Rückgabewert:** Die Funktion gibt `0` bei Erfolg oder einen Fehlercode ungleich Null bei einem Fehlschlag zurück.<br /><br />#### Python/Ctypes Integration<br /><br />Für den Aufruf aus Python mit `ctypes` müssen die `void*` Parameter durch `ctypes.c_void_p` ersetzt werden, die die Handles der `cl_mem` GPU-Buffer enthalten. Die Dimensionsparameter `B`, `S`, `E` und `T` werden als Standard-Integer übergeben.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_dynamic_token_assignment_gpu(int gpu_index, void* activations_bse, void* prototypes_te, void* output_indices_bs, int B, int S, int E, int T);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_dynamic_token_assignment_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_dynamic_token_assignment_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int, c_int]
lib.execute_dynamic_token_assignment_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_dynamic_token_assignment_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0, 0)

print(f"Call to 'execute_dynamic_token_assignment_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_embedding_backward_gpu">
        <h2>execute_embedding_backward_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.embedding</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>d_o</code></td></tr><tr><td><code>void*</code></td><td><code>idx</code></td></tr><tr><td><code>void*</code></td><td><code>d_w</code></td></tr><tr><td><code>int</code></td><td><code>b</code></td></tr><tr><td><code>int</code></td><td><code>s</code></td></tr><tr><td><code>int</code></td><td><code>d</code></td></tr><tr><td><code>int</code></td><td><code>v</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_embedding_backward_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Diese Funktion führt den Backward-Pass für eine Embedding-Schicht auf der GPU aus. Sie berechnet die Gradienten für die Embedding-Gewichtsmatrix (`d_w`), indem sie die Upstream-Gradienten (`d_o`) basierend auf den im Forward-Pass verwendeten Token-Indizes (`idx`) akkumuliert. Diese Operation ist ein wesentlicher Bestandteil des Backpropagation-Prozesses in neuronalen Netzen mit Embedding-Schichten.<br /><br />#### Anwendungshinweise<br /><br />- **Voraussetzungen:** Die GPU muss zuvor mit `initialize_gpu` initialisiert und alle Puffer (`d_o`, `idx`, `d_w`) müssen auf dem Gerätespeicher (`device`) allokiert sein.<br />- **Puffergrößen:** Die Größe der Puffer muss exakt den Dimensionsparametern entsprechen:<br />    - `d_o` (Upstream-Gradient): `b * s * d * sizeof(float)`<br />    - `idx` (Token-Indizes): `b * s * sizeof(int)`<br />    - `d_w` (Gewichtsgradienten): `v * d * sizeof(float)`<br />- **Akkumulation:** Der Kernel akkumuliert die Gradienten in `d_w` additiv. Stellen Sie sicher, dass der `d_w`-Puffer vor Beginn eines Backpropagation-Durchgangs (z. B. zu Beginn jeder Epoche) auf null initialisiert wird.<br />- **Synchroner Aufruf:** Die Funktion blockiert, bis die GPU-Berechnung abgeschlossen ist.<br />- **Rückgabewert:** Gibt `0` bei Erfolg oder einen negativen Fehlercode bei einem Fehler zurück.<br /><br />#### `ctypes` Integration<br /><br />Ersetzen Sie in Ihrem Python-`ctypes`-Wrapper die `void*`-Parameter durch `ctypes.c_void_p`-Objekte, die auf die zuvor allokierten GPU-Puffer verweisen. Die Dimensionsparameter `b`, `s`, `d` und `v` werden als reguläre Python-Integer übergeben.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_embedding_backward_gpu(int gpu_index, void* d_o, void* idx, void* d_w, int b, int s, int d, int v);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_embedding_backward_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_embedding_backward_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int, c_int]
lib.execute_embedding_backward_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_embedding_backward_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0, 0)

print(f"Call to 'execute_embedding_backward_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_embedding_lookup_gpu">
        <h2>execute_embedding_lookup_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.embedding</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>idx</code></td></tr><tr><td><code>void*</code></td><td><code>w</code></td></tr><tr><td><code>void*</code></td><td><code>o</code></td></tr><tr><td><code>int</code></td><td><code>b</code></td></tr><tr><td><code>int</code></td><td><code>s</code></td></tr><tr><td><code>int</code></td><td><code>d</code></td></tr><tr><td><code>int</code></td><td><code>v</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_embedding_lookup_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt ein paralleles Embedding-Lookup auf der GPU aus. Die Funktion extrahiert Vektoren aus einer Gewichtsmatrix (`w`) basierend auf den Indizes im Eingabepuffer (`idx`) und schreibt die Ergebnisse in den Ausgabepuffer (`o`). Diese Operation ist ein grundlegender Baustein in Deep-Learning-Modellen, insbesondere im Bereich NLP, um Token-IDs in dichte Vektorrepräsentationen umzuwandeln.<br /><br />#### Hinweise zur Verwendung<br /><br />*   **Voraussetzungen:** Die Zeiger `idx`, `w` und `o` müssen auf gültige, zuvor auf der GPU allokierte Speicherpuffer verweisen (z.B. via `create_buffer`). Die GPU muss mit `initialize_gpu` initialisiert worden sein.<br />*   **Puffergrößen:**<br />    *   `idx` (Eingabe-Indizes): Muss `b * s` 32-Bit-Integer-Werte aufnehmen können.<br />    *   `w` (Gewichtsmatrix): Muss `v * d` Fließkommazahlen (FP32) enthalten.<br />    *   `o` (Ausgabe): Muss für `b * s * d` Fließkommazahlen (FP32) dimensioniert sein.<br />*   **Index-Gültigkeit:** Alle Werte im `idx`-Puffer müssen im gültigen Bereich `[0, v-1]` liegen. Indizes außerhalb dieses Bereichs führen zu undefiniertem Verhalten.<br />*   **Lebenszyklus:** Der Aufrufer ist für die Erstellung, Befüllung und Freigabe (`release_buffer`) aller GPU-Puffer verantwortlich.<br />*   **Rückgabewert:** Gibt `0` bei Erfolg oder einen OpenCL-Fehlercode bei einem Fehlschlag zurück.<br /><br />#### Python `ctypes` Integration<br /><br />In einem Python `ctypes`-Wrapper müssen die `void*`-Argumente (`idx`, `w`, `o`) durch `c_void_p`-Zeiger ersetzt werden, die von der Puffererstellungsfunktion zurückgegeben wurden. Die Längenargumente `b, s, d, v` müssen den Dimensionen der entsprechenden Tensoren entsprechen.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_embedding_lookup_gpu(int gpu_index, void* idx, void* w, void* o, int b, int s, int d, int v);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_embedding_lookup_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_embedding_lookup_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int, c_int]
lib.execute_embedding_lookup_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_embedding_lookup_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0, 0)

print(f"Call to 'execute_embedding_lookup_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_gelu_backward_on_gpu">
        <h2>execute_gelu_backward_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_input</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_grad_output</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_grad_input</code></td></tr><tr><td><code>int</code></td><td><code>num_elements</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">Absolut. Hier ist die Dokumentation für `execute_gelu_backward_on_gpu`.<br /><br />---<br /><br />### `execute_gelu_backward_on_gpu`<br /><br />#### Beschreibung<br /><br />Berechnet den Backward-Pass für die GELU-Aktivierungsfunktion (Gaussian Error Linear Unit) auf einer bestimmten GPU. Diese Funktion wird typischerweise während der Backpropagation beim Training eines neuronalen Netzes verwendet. Sie ermittelt den Gradienten bezüglich des Inputs der GELU-Schicht, basierend auf dem ursprünglichen Input und dem vom nachfolgenden Layer kommenden Gradienten.<br /><br />#### Verwendungshinweise<br /><br />*   **Voraussetzung:** `initialize_opencl(gpu_index)` muss vor dem Aufruf dieser Funktion erfolgreich ausgeführt worden sein.<br />*   **Buffer-Größe:** Die drei Buffer (`buffer_input`, `buffer_grad_output`, `buffer_grad_input`) müssen zuvor auf der GPU (z.B. mit `create_buffer_on_gpu`) alloziert werden. Jeder Buffer muss eine Größe von mindestens `num_elements * sizeof(float)` haben.<br />*   **Datentyp:** Die Funktion operiert ausschließlich auf Buffern mit 32-Bit-Gleitkommazahlen (`float`).<br />*   **Ausgabebuffer:** Der Inhalt von `buffer_grad_input` wird mit dem Ergebnis der Berechnung überschrieben.<br />*   **Fehlercodes:** Gibt `0` bei Erfolg zurück. Ein Wert ungleich null signalisiert einen Fehler. Details können mit `get_last_error_string()` abgerufen werden.<br /><br />#### Python ctypes Beispiel<br /><br />Der folgende Codeausschnitt zeigt, wie die Funktion über `ctypes` aufgerufen wird. Ersetzen Sie die Platzhalter (`gpu_index_val`, `buffer_*_ptr`, `num_elements_val`) durch Ihre tatsächlichen Variablen, die den GPU-Index, die Pointer zu den GPU-Buffern und die Anzahl der Elemente enthalten.<br /><br />```python<br /># Annahme: 'dll' ist das geladene CipherCore_OpenCl.dll-Objekt<br /># Annahme: Buffer-Pointer (z.B. buffer_input_ptr) wurden zuvor erstellt<br /><br />result = dll.execute_gelu_backward_on_gpu(<br />    gpu_index_val,<br />    buffer_input_ptr,<br />    buffer_grad_output_ptr,<br />    buffer_grad_input_ptr,<br />    num_elements_val<br />)<br /><br />if result != 0:<br />    print("Fehler bei der Ausführung des GELU Backward-Kerns.")<br /><br />```</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_gelu_backward_on_gpu(int gpu_index, void* buffer_input, void* buffer_grad_output, void* buffer_grad_input, int num_elements);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_gelu_backward_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_gelu_backward_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int]
lib.execute_gelu_backward_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_gelu_backward_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_gelu_backward_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_gelu_on_gpu">
        <h2>execute_gelu_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_input</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_output</code></td></tr><tr><td><code>int</code></td><td><code>num_elements</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_gelu_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Diese Funktion wendet die GELU-Aktivierungsfunktion (Gaussian Error Linear Unit) elementweise auf einen Datenpuffer auf der angegebenen GPU an. Sie wird typischerweise in den Schichten von neuronalen Netzen, wie z.B. Transformer-Modellen, zur Einführung von Nichtlinearität eingesetzt. Die Operation liest aus einem Eingabepuffer und schreibt das Ergebnis in einen separaten Ausgabepuffer.<br /><br />#### Anwendungshinweise<br /><br />-   Die OpenCL-Umgebung muss vor dem Aufruf dieser Funktion initialisiert worden sein.<br />-   Der Eingabe- (`buffer_input`) und Ausgabepuffer (`buffer_output`) müssen vorab auf der GPU alloziert werden und dieselbe Größe haben: `num_elements * sizeof(float)`.<br />-   Die Funktion erwartet, dass die Puffer 32-Bit-Gleitkommazahlen (single-precision `float`) enthalten.<br />-   Der Aufrufer ist für die Verwaltung (Allokation und Freigabe) der GPU-Puffer verantwortlich.<br />-   Gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehler (z.B. ungültiger GPU-Index oder Fehler bei der Kernel-Ausführung).<br /><br />#### Python `ctypes` Integration<br /><br />Passen Sie im `ctypes`-Codebeispiel die Zeiger für `buffer_input` und `buffer_output` sowie den Wert für `num_elements` an Ihre allozierten Puffer und Daten an.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_gelu_on_gpu(int gpu_index, void* buffer_input, void* buffer_output, int num_elements);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_gelu_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_gelu_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int]
lib.execute_gelu_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_gelu_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_gelu_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_grover_gpu">
        <h2>execute_grover_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>int</code></td><td><code>num_qubits</code></td></tr><tr><td><code>int</code></td><td><code>iterations</code></td></tr><tr><td><code>uint64_t</code></td><td><code>marked_mask</code></td></tr><tr><td><code>uint64_t</code></td><td><code>marked_value</code></td></tr><tr><td><code>int*</code></td><td><code>out_marked_state</code></td></tr><tr><td><code>float*</code></td><td><code>out_distribution</code></td></tr><tr><td><code>int</code></td><td><code>distribution_length</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_grover_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt den Grover-Quantensuchalgorithmus auf einer bestimmten GPU aus. Diese Funktion simuliert die Suche nach einem oder mehreren "markierten" Zuständen, indem sie den Grover-Orakel- und Diffusionsoperator für eine angegebene Anzahl von Iterationen anwendet. Sie ist für die Lösung unstrukturierter Suchprobleme konzipiert.<br /><br />#### Anwendungshinweise<br /><br />- Die GPU muss vor dem Aufruf dieser Funktion initialisiert werden.<br />- Der Aufrufer ist für die Allokation der Ausgabepuffer verantwortlich. `out_distribution` muss eine Länge von `2^num_qubits` haben (`distribution_length`). `out_marked_state` ist ein Zeiger auf einen einzelnen `int`.<br />- `marked_mask` und `marked_value` definieren den gesuchten Zustand. Ein Zustand `s` ist markiert, wenn `(s & marked_mask) == marked_value` gilt.<br />- Die optimale Anzahl von `iterations` liegt typischerweise bei `round((π/4) * sqrt(2^num_qubits))`.<br />- Die maximale Anzahl von `num_qubits` ist durch den verfügbaren GPU-Speicher begrenzt (typischerweise 25-30).<br />- Die Funktion gibt `0` bei Erfolg und einen negativen Fehlercode bei einem Fehler zurück.<br /><br />#### Hinweis zur Ctypes-Nutzung<br /><br />Bei der Verwendung mit Python und `ctypes` müssen die Ausgabepuffer (`out_marked_state`, `out_distribution`) vom Aufrufer vorab alloziert werden. Übergeben Sie Zeiger auf die entsprechenden `ctypes`- oder NumPy-Objekte und stellen Sie sicher, dass `distribution_length` mit der Größe des `out_distribution`-Puffers übereinstimmt.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_grover_gpu(int gpu_index, int num_qubits, int iterations,
                                 uint64_t marked_mask, uint64_t marked_value,
                                 int* out_marked_state,
                                 float* out_distribution, int distribution_length);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_grover_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_grover_gpu.argtypes = [c_int, c_int, c_int, c_uint64, c_uint64, POINTER(c_int), POINTER(c_float), c_int]
lib.execute_grover_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_grover_gpu(0, 0, 0, 0, 0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_grover_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_hebbian_update_on_gpu">
        <h2>execute_hebbian_update_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.bio</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_a</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_c</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_w</code></td></tr><tr><td><code>float</code></td><td><code>learning_rate</code></td></tr><tr><td><code>int</code></td><td><code>B</code></td></tr><tr><td><code>int</code></td><td><code>M</code></td></tr><tr><td><code>int</code></td><td><code>N</code></td></tr><tr><td><code>int</code></td><td><code>K</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_hebbian_update_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt ein Batch-basiertes Hebb'sches Gewichtsupdate auf einer spezifizierten GPU durch. Diese Funktion modifiziert eine Gewichtsmatrix `W` basierend auf der Korrelation der Aktivierungsmatrizen `A` und `C`, skaliert um eine Lernrate. Sie wird typischerweise zum Training von biologisch inspirierten oder Prototypen-basierten neuronalen Netzen verwendet.<br /><br />#### Anwendungshinweise<br /><br />-   **Voraussetzungen:** Der OpenCL-Kontext muss mit `initialize_opencl()` initialisiert und die GPU-Puffer (`buffer_a`, `buffer_c`, `buffer_w`) müssen mit `create_buffer_on_gpu()` auf dem Ziel-GPU alloziert sein.<br />-   **Puffergrößen:**<br />    -   `buffer_a` muss eine Größe von mindestens `B * M * K * sizeof(float)` haben.<br />    -   `buffer_c` muss eine Größe von mindestens `B * N * K * sizeof(float)` haben.<br />    -   `buffer_w` muss eine Größe von mindestens `M * N * sizeof(float)` haben. Dieser Puffer wird direkt auf der GPU (in-place) modifiziert.<br />-   **Speicherverwaltung:** Der Aufrufer ist für die Verwaltung der GPU-Puffer verantwortlich, einschließlich Allokation und Freigabe mittels `release_buffer_on_gpu()`.<br />-   **Rückgabewert:** Gibt `0` bei Erfolg zurück. Ein negativer Fehlercode signalisiert einen Fehler (z.B. ungültiger `gpu_index`, Fehler bei der OpenCL-Kernel-Ausführung).<br /><br />#### Hinweis zur ctypes-Nutzung<br /><br />Im ctypes-Code-Snippet müssen die `void*`-Parameter (`buffer_a`, `buffer_c`, `buffer_w`) durch die tatsächlichen Pointer-Objekte der GPU-Puffer ersetzt werden. Die Ganzzahl-Parameter für die Dimensionen (`B`, `M`, `N`, `K`) müssen den Größen der Matrizen entsprechen, die bei der Puffer-Allokation verwendet wurden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_hebbian_update_on_gpu(int gpu_index, void* buffer_a, void* buffer_c, void* buffer_w, float learning_rate, int B, int M, int N, int K);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_hebbian_update_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_hebbian_update_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_float, c_int, c_int, c_int, c_int]
lib.execute_hebbian_update_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_hebbian_update_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0.0, 0, 0, 0, 0)

print(f"Call to 'execute_hebbian_update_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_hhl_gpu">
        <h2>execute_hhl_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>const float*</code></td><td><code>matrix_A</code></td></tr><tr><td><code>const float*</code></td><td><code>vector_b</code></td></tr><tr><td><code>int</code></td><td><code>system_size</code></td></tr><tr><td><code>float*</code></td><td><code>out_solution</code></td></tr><tr><td><code>int</code></td><td><code>solution_length</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_hhl_gpu`<br /><br />#### Beschreibung<br /><br />Führt eine GPU-beschleunigte Simulation des HHL-Quantenalgorithmus aus, um ein lineares Gleichungssystem der Form Ax = b zu lösen. Diese Funktion wird verwendet, um den Lösungsvektor `x` für eine gegebene quadratische Matrix `A` und einen Vektor `b` zu finden. Der Algorithmus ist für hermitesche Matrizen mit einer Dimension, die eine Zweierpotenz ist, optimiert.<br /><br />#### Anwendungshinweise<br /><br />*   Die OpenCL-Umgebung muss vor dem Aufruf dieser Funktion erfolgreich mit `initialize_opencl` initialisiert worden sein.<br />*   Die Matrix `A` muss quadratisch, hermitesch und als flaches Array der Größe `system_size * system_size` im Row-Major-Format vorliegen.<br />*   Die Dimension `system_size` muss eine Zweierpotenz sein (z. B. 4, 8, 16, ...).<br />*   Die Puffer für `vector_b` und `out_solution` müssen vom Aufrufer alloziert werden und eine Länge von `system_size` haben (`solution_length` muss `system_size` entsprechen).<br />*   Die Funktion gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen spezifischen OpenCL-Fehlercode.<br /><br />#### Python (ctypes) Anbindung<br /><br />Im ctypes-Code-Snippet müssen die Zeiger für `matrix_A`, `vector_b` und `out_solution` sowie die Längenvariablen (`system_size`, `solution_length`) durch Referenzen auf die entsprechenden NumPy-Arrays und deren Dimensionen ersetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_hhl_gpu(int gpu_index, const float* matrix_A, const float* vector_b,
                              int system_size, float* out_solution, int solution_length);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_hhl_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_hhl_gpu.argtypes = [c_int, POINTER(c_float), POINTER(c_float), c_int, POINTER(c_float), c_int]
lib.execute_hhl_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_hhl_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_hhl_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_layernorm_backward_on_gpu">
        <h2>execute_layernorm_backward_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.layernorm</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dy</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_x</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dx</code></td></tr><tr><td><code>int</code></td><td><code>num_rows</code></td></tr><tr><td><code>int</code></td><td><code>row_size</code></td></tr><tr><td><code>float</code></td><td><code>eps</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### kernel.layernorm / execute_layernorm_backward_on_gpu<br /><br />#### Beschreibung<br />Führt die Backpropagation (Rückwärtspass) für eine Layer-Normalisierungs-Operation auf der GPU aus. Diese Funktion berechnet den Gradienten bezüglich der Eingabe (`dx`) unter Verwendung des ursprünglichen Eingabe-Tensors (`x`) und des Gradienten des nachfolgenden Layers (`dy`). Sie wird typischerweise während der Trainingsphase eines neuronalen Netzes aufgerufen.<br /><br />#### Anwendungshinweise<br />- Die GPU muss vor dem Aufruf dieser Funktion mit `initialize_gpu` initialisiert worden sein.<br />- Die drei Buffer (`buffer_dy`, `buffer_x`, `buffer_dx`) müssen vorab auf der GPU alloziert werden und dieselbe Größe haben: `num_rows * row_size * sizeof(float)`.<br />- `buffer_dy` und `buffer_x` dienen als Eingabe; `buffer_dx` ist der Ausgabebuffer, der das Ergebnis (`dx`) empfängt.<br />- Der `eps`-Wert muss mit dem Wert übereinstimmen, der im korrespondierenden Forward-Pass verwendet wurde, um numerische Konsistenz zu gewährleisten.<br />- Rückgabewert ist `0` bei Erfolg oder ein Fehlercode (ungleich null) bei einem Problem.<br /><br />#### Python ctypes Beispiel<br />Für den Aufruf aus Python mittels `ctypes` müssen die `void*`-Parameter als `ctypes.c_void_p` übergeben werden, die auf die zuvor auf der GPU erstellten Buffer verweisen.<br /><br />```python<br /># Annahme: 'lib' ist das geladene DLL-Objekt und die GPU-Buffer sind bereits alloziert.<br /># Setzen Sie die korrekten Argumenttypen für die Funktion.<br /># ...<br /><br />exit_code = lib.execute_layernorm_backward_on_gpu(<br />    gpu_index,<br />    ctypes.c_void_p(gpu_buffer_dy_ptr),<br />    ctypes.c_void_p(gpu_buffer_x_ptr),<br />    ctypes.c_void_p(gpu_buffer_dx_ptr),<br />    num_rows,<br />    row_size,<br />    ctypes.c_float(eps)<br />)<br />```<br />Ersetzen Sie `gpu_buffer_*_ptr` durch die tatsächlichen Pointer-Adressen Ihrer GPU-Buffer und `num_rows`, `row_size` sowie `eps` durch die entsprechenden Werte Ihrer Tensoren.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_layernorm_backward_on_gpu(int gpu_index, void* buffer_dy, void* buffer_x, void* buffer_dx, int num_rows, int row_size, float eps);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_layernorm_backward_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_layernorm_backward_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int, c_int, c_float]
lib.execute_layernorm_backward_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_layernorm_backward_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0.0)

print(f"Call to 'execute_layernorm_backward_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_layernorm_on_gpu">
        <h2>execute_layernorm_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.layernorm</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_input</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_output</code></td></tr><tr><td><code>int</code></td><td><code>num_rows</code></td></tr><tr><td><code>int</code></td><td><code>row_size</code></td></tr><tr><td><code>float</code></td><td><code>eps</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_layernorm_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt eine Layer-Normalisierung für einen 2D-Datenpuffer auf dem angegebenen GPU-Gerät durch. Diese Operation normalisiert die Eingaben über die Feature-Dimension (Zeilengröße) für jede einzelne Zeile (Datenpunkt). Sie ist ein grundlegender Baustein in vielen neuronalen Netzwerken, insbesondere bei Transformer-Architekturen, um die Trainingsstabilität zu verbessern.<br /><br />#### Hinweise zur Verwendung<br /><br />*   **Voraussetzung:** Die Puffer `buffer_input` und `buffer_output` müssen bereits auf der GPU mit der passenden Größe (`num_rows * row_size * sizeof(float)`) alloziert sein. Sie repräsentieren GPU-Speicher-Handles, nicht CPU-Zeiger.<br />*   **Puffergröße:** `buffer_input` und `buffer_output` müssen die gleiche Größe haben. Die Operation wird "in-place" nicht unterstützt; die Puffer müssen unterschiedliche Speicherbereiche belegen.<br />*   **Datenformat:** Die Operation wird auf 32-Bit-Fließkommazahlen (`float`) durchgeführt.<br />*   **Parameter `eps`:** Der `eps`-Wert (Epsilon) ist ein kleiner Fließkommawert (z. B. `1e-5`), der zur Varianz addiert wird, um eine Division durch Null zu verhindern und die numerische Stabilität zu gewährleisten.<br />*   **Rückgabewert:** Die Funktion gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehlercode (z. B. einen OpenCL-Fehler oder ungültige Parameter).<br /><br />#### Python `ctypes` Integration<br /><br />Im Python `ctypes`-Aufruf müssen die Platzhalter für `buffer_input` und `buffer_output` durch die von der Speicherallokationsfunktion zurückgegebenen `c_void_p`-Zeiger ersetzt werden. Die Parameter `num_rows` und `row_size` müssen den Dimensionen der allokierten Puffer entsprechen.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_layernorm_on_gpu(int gpu_index, void* buffer_input, void* buffer_output, int num_rows, int row_size, float eps);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_layernorm_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_layernorm_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int, c_int, c_float]
lib.execute_layernorm_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_layernorm_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0.0)

print(f"Call to 'execute_layernorm_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_log_softmax_stable_gpu">
        <h2>execute_log_softmax_stable_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.softmax</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>input_logits</code></td></tr><tr><td><code>void*</code></td><td><code>output_log_probs</code></td></tr><tr><td><code>int</code></td><td><code>B_S_rows</code></td></tr><tr><td><code>int</code></td><td><code>V_cols</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_log_softmax_stable_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Berechnet den Logarithmus der Softmax-Funktion auf der GPU für eine 2D-Eingabematrix (Logits). Diese Implementierung ist numerisch stabil, da sie vor der Exponentiation den maximalen Wert jeder Zeile subtrahiert, um numerische Überläufe bei großen Eingabewerten zu verhindern. Die Funktion wird typischerweise als letzte Schicht in Klassifikationsmodellen eingesetzt, um Log-Wahrscheinlichkeiten für die Verlustberechnung zu erzeugen.<br /><br />#### Anwendungshinweise<br /><br />- **Voraussetzung:** Der OpenCL-Treiber muss über `init_opencl_driver` für den angegebenen `gpu_index` initialisiert sein.<br />- **GPU-Puffer:** `input_logits` und `output_log_probs` müssen gültige `cl_mem`-Puffer sein, die auf der Ziel-GPU mit `create_buffer_on_gpu` erstellt wurden.<br />- **Puffergröße:** Beide Puffer müssen für `B_S_rows * V_cols` Float-Werte (`sizeof(float)`) alloziert sein.<br />- **Rückgabewert:** Gibt `0` bei erfolgreicher Ausführung zurück. Ein Wert ungleich null signalisiert einen Fehler (z. B. `ERR_INVALID_GPU_INDEX`, `ERR_KERNEL_EXECUTION`).<br />- **Speicherverwaltung:** Die GPU-Puffer müssen vom Aufrufer verwaltet (erstellt und freigegeben) werden.<br /><br />#### Python `ctypes` Beispiel<br /><br />Für den Aufruf aus Python müssen die `void*`-Argumente (`input_logits`, `output_log_probs`) als `ctypes.c_void_p` übergeben werden, die die von `create_buffer_on_gpu` zurückgegebenen Handles enthalten. Die Ganzzahl-Argumente `B_S_rows` und `V_cols` müssen den Dimensionen entsprechen, die bei der Erstellung der Puffer verwendet wurden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_log_softmax_stable_gpu(int gpu_index, void* input_logits, void* output_log_probs, int B_S_rows, int V_cols);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_log_softmax_stable_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_log_softmax_stable_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int, c_int]
lib.execute_log_softmax_stable_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_log_softmax_stable_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0)

print(f"Call to 'execute_log_softmax_stable_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_matmul_backward_on_gpu">
        <h2>execute_matmul_backward_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.matmul</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_a</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_b</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dc</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_da</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_db</code></td></tr><tr><td><code>int</code></td><td><code>B</code></td></tr><tr><td><code>int</code></td><td><code>M</code></td></tr><tr><td><code>int</code></td><td><code>N</code></td></tr><tr><td><code>int</code></td><td><code>K</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### execute_matmul_backward_on_gpu<br /><br />#### Kurzbeschreibung<br /><br />Führt den Backward-Pass (Gradientenberechnung) für eine batched Matrixmultiplikation auf einem bestimmten GPU-Gerät aus. Diese Funktion berechnet die Gradienten bezüglich der Eingabematrizen A (`dA`) und B (`dB`), basierend auf dem Upstream-Gradienten `dC` und den ursprünglichen Eingabematrizen A und B. Sie implementiert die Operationen `dA = dC @ B^T` und `dB = A^T @ dC`, die für die Backpropagation in neuronalen Netzen benötigt werden.<br /><br />#### Anwendungshinweise<br /><br />-   **Vorbedingungen:** Die OpenCL-Umgebung muss initialisiert und alle Buffer müssen bereits auf der Ziel-GPU alloziert sein.<br />-   **Buffer-Handling:** Die `void*` Parameter sind Handles (Pointer) zu auf der GPU allozierten Buffern, keine Host-RAM-Pointer.<br />-   **Buffer-Größen:** Der Aufrufer ist für die korrekte Allokation der Buffer verantwortlich. Bei Verwendung von 32-Bit-Floats (`float`) gelten folgende Größen:<br />    -   `buffer_a`, `buffer_da`: `B * M * K * sizeof(float)`<br />    -   `buffer_b`, `buffer_db`: `B * K * N * sizeof(float)`<br />    -   `buffer_dc`: `B * M * N * sizeof(float)`<br />-   **Datenfluss:** `buffer_a`, `buffer_b` und `buffer_dc` sind Eingabeparameter. `buffer_da` und `buffer_db` sind Ausgabeparameter, deren Inhalt überschrieben wird.<br />-   **Rückgabewert:** Gibt `0` bei Erfolg oder einen negativen Fehlercode bei einem Problem zurück.<br /><br />#### Python ctypes Snippet<br /><br />Im Python `ctypes`-Wrapper muss die Funktionssignatur definiert werden. Ersetzen Sie im Funktionsaufruf die Platzhalter (`gpu_idx`, `ptr_A`, `B_val` etc.) durch Ihre tatsächlichen Werte und GPU-Buffer-Pointer.<br /><br />```python<br />import ctypes<br /><br /># Lade die DLL<br />lib = ctypes.CDLL("CipherCore_OpenCl.dll")<br /><br /># Definiere die Funktionssignatur<br />execute_matmul_backward_on_gpu = lib.execute_matmul_backward_on_gpu<br />execute_matmul_backward_on_gpu.restype = ctypes.c_int<br />execute_matmul_backward_on_gpu.argtypes = [<br />    ctypes.c_int,      # gpu_index<br />    ctypes.c_void_p,   # buffer_a<br />    ctypes.c_void_p,   # buffer_b<br />    ctypes.c_void_p,   # buffer_dc<br />    ctypes.c_void_p,   # buffer_da<br />    ctypes.c_void_p,   # buffer_db<br />    ctypes.c_int,      # B<br />    ctypes.c_int,      # M<br />    ctypes.c_int,      # N<br />    ctypes.c_int       # K<br />]<br /><br /># Beispielhafter Aufruf mit Platzhaltern<br /># ptr_A, ptr_B, etc. sind c_void_p, die von einer Buffer-Allocations-Funktion stammen<br />status = execute_matmul_backward_on_gpu(<br />    gpu_idx,<br />    ptr_A,<br />    ptr_B,<br />    ptr_dC,<br />    ptr_dA,<br />    ptr_dB,<br />    B_val,<br />    M_val,<br />    N_val,<br />    K_val<br />)<br /><br />if status != 0:<br />    print(f"Fehler bei der Ausführung: {status}")<br /><br />```</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_matmul_backward_on_gpu(int gpu_index, void* buffer_a, void* buffer_b, void* buffer_dc, void* buffer_da, void* buffer_db, int B, int M, int N, int K);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_matmul_backward_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_matmul_backward_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int, c_int]
lib.execute_matmul_backward_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_matmul_backward_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0, 0)

print(f"Call to 'execute_matmul_backward_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_matmul_batched_backward_on_gpu">
        <h2>execute_matmul_batched_backward_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.matmul</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_a</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_b</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dc</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_da</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_db</code></td></tr><tr><td><code>int</code></td><td><code>B</code></td></tr><tr><td><code>int</code></td><td><code>M</code></td></tr><tr><td><code>int</code></td><td><code>N</code></td></tr><tr><td><code>int</code></td><td><code>K</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_matmul_batched_backward_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt den Backward-Pass für eine gebatchte Matrizenmultiplikation auf der GPU aus. Diese Funktion berechnet die Gradienten der Eingabematrizen `A` und `B` (`dA`, `dB`) basierend auf dem Gradienten der Ausgabematrix `dC`. Sie wird typischerweise während des Trainings von neuronalen Netzen im Rahmen der Backpropagation verwendet.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzungen:** Der GPU-Kontext muss initialisiert und der Kernel kompiliert sein. Die Eingabe-Buffer (`buffer_a`, `buffer_b`, `buffer_dc`) und Ausgabe-Buffer (`buffer_da`, `buffer_db`) müssen bereits auf der Ziel-GPU alloziert sein.<br />*   **Buffer-Größen:** Die Größe der Buffer muss den Matrixdimensionen entsprechen (Datentyp ist `float`):<br />    *   `buffer_a`, `buffer_da`: `B * M * K * sizeof(float)`<br />    *   `buffer_b`, `buffer_db`: `B * K * N * sizeof(float)`<br />    *   `buffer_dc`: `B * M * N * sizeof(float)`<br />*   **Datenfluss:** `buffer_a`, `buffer_b` und `buffer_dc` sind reine Eingabe-Buffer. `buffer_da` und `buffer_db` sind reine Ausgabe-Buffer, deren Inhalt überschrieben wird.<br />*   **Rückgabewert:** Gibt `0` bei Erfolg zurück, andernfalls einen Fehlercode ungleich Null.<br /><br />#### Python `ctypes` Beispiel<br /><br />Für die Anbindung via `ctypes` müssen die Funktionsparameter gesetzt werden. Ersetzen Sie die Platzhalter für die Buffer-Zeiger mit den von der Speicherverwaltungsfunktion erhaltenen `ctypes.c_void_p`-Objekten und geben Sie die korrekten Integer-Werte für die Dimensionen `B`, `M`, `N` und `K` an.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_matmul_batched_backward_on_gpu(int gpu_index, void* buffer_a, void* buffer_b, void* buffer_dc, void* buffer_da, void* buffer_db, int B, int M, int N, int K);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_matmul_batched_backward_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_matmul_batched_backward_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int, c_int]
lib.execute_matmul_batched_backward_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_matmul_batched_backward_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0, 0)

print(f"Call to 'execute_matmul_batched_backward_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_matmul_batched_on_gpu">
        <h2>execute_matmul_batched_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.matmul</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_a</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_b</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_c</code></td></tr><tr><td><code>int</code></td><td><code>B</code></td></tr><tr><td><code>int</code></td><td><code>M</code></td></tr><tr><td><code>int</code></td><td><code>N</code></td></tr><tr><td><code>int</code></td><td><code>K</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_matmul_batched_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Diese Funktion führt eine gestapelte (batched) Matrizenmultiplikation auf einer spezifizierten GPU durch. Sie berechnet die Operation `C = A * B` für einen Stapel (`B`) von Matrizen. Diese Funktion ist optimiert für die parallele Verarbeitung vieler gleich großer Matrizenmultiplikationen, wie sie typischerweise in den Schichten neuronaler Netze vorkommen.<br /><br />#### Verwendungshinweise<br /><br />*   Die OpenCL-Umgebung muss vor dem Aufruf mit `initialize_opencl` initialisiert worden sein.<br />*   Die Puffer `buffer_a`, `buffer_b` und `buffer_c` müssen bereits auf der Ziel-GPU mit `allocate_buffer_on_gpu` alloziert worden sein.<br />*   Die Größe der Puffer muss den Dimensionsparametern entsprechen: `buffer_a` (B * M * K * `sizeof(float)`), `buffer_b` (B * K * N * `sizeof(float)`), und `buffer_c` (B * M * N * `sizeof(float)`).<br />*   Die Matrizen werden im Row-Major-Format erwartet.<br />*   Gibt `CL_SUCCESS` (0) bei Erfolg oder einen OpenCL-Fehlercode bei einem Fehlschlag zurück.<br /><br />#### Python ctypes-Integration<br /><br />Im Python ctypes-Codeausschnitt müssen die Platzhalter für die Puffer-Zeiger (`buffer_a_ptr`, `buffer_b_ptr`, `buffer_c_ptr`) durch die von `allocate_buffer_on_gpu` zurückgegebenen `c_void_p`-Objekte ersetzt werden. Die Dimensionsvariablen `B`, `M`, `N`, und `K` müssen ebenfalls mit den korrekten Integer-Werten belegt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_matmul_batched_on_gpu(int gpu_index, void* buffer_a, void* buffer_b, void* buffer_c, int B, int M, int N, int K);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_matmul_batched_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_matmul_batched_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int, c_int]
lib.execute_matmul_batched_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_matmul_batched_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0, 0)

print(f"Call to 'execute_matmul_batched_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_matmul_on_gpu">
        <h2>execute_matmul_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.matmul</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_a</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_b</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_c</code></td></tr><tr><td><code>int</code></td><td><code>B</code></td></tr><tr><td><code>int</code></td><td><code>M</code></td></tr><tr><td><code>int</code></td><td><code>N</code></td></tr><tr><td><code>int</code></td><td><code>K</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### Kurzbeschreibung<br /><br />Diese Funktion führt eine gebündelte (batched) Matrixmultiplikation (`C = A * B`) auf einem spezifizierten OpenCL-fähigen Gerät (GPU) aus. Sie ist für die Beschleunigung von rechenintensiven Operationen der linearen Algebra konzipiert, wie sie häufig in Deep-Learning- und wissenschaftlichen Berechnungen vorkommen. Die Funktion handhabt die Datenübertragung zum und vom Gerät, die Kernel-Ausführung und die Synchronisation.<br /><br />### Anwendungshinweise<br /><br />*   Die Buffer `buffer_a`, `buffer_b` und `buffer_c` müssen auf bereits allozierten Speicher auf dem Host (CPU) zeigen.<br />*   Die Größe der Buffer muss den Dimensionen `B, M, N, K` entsprechen (angenommen wird der Datentyp `float`):<br />    *   `buffer_a`: `B * M * K * sizeof(float)` Bytes für die Matrix A (Shape: B, M, K).<br />    *   `buffer_b`: `B * K * N * sizeof(float)` Bytes für die Matrix B (Shape: B, K, N).<br />    *   `buffer_c`: `B * M * N * sizeof(float)` Bytes für die Ergebnismatrix C (Shape: B, M, N).<br />*   Der `gpu_index` muss einem gültigen, verfügbaren OpenCL-Gerät entsprechen. Ein Index von 0 wählt typischerweise das Standardgerät.<br />*   Die Ausführung ist synchron. Nach erfolgreicher Rückkehr der Funktion enthält `buffer_c` das Ergebnis der Multiplikation.<br />*   Gibt `0` bei Erfolg zurück. Ein Wert ungleich `0` signalisiert einen Fehler während der OpenCL-Kernel-Ausführung oder bei der Parameterprüfung.<br /><br />### Python ctypes Beispiel<br /><br />Um diese Funktion mit `ctypes` in Python zu verwenden, ersetzen Sie die Platzhalter in einem Aufruf-Snippet mit den entsprechenden `ctypes`-Zeigern und den Integer-Dimensionen Ihrer Matrizen. Den Pointer auf die Daten eines NumPy-Arrays erhalten Sie über das Attribut `.ctypes.data_as(ctypes.c_void_p)`. Stellen Sie sicher, dass die NumPy-Arrays C-kontinuierlich sind und den Datentyp `float32` haben.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_matmul_on_gpu(int gpu_index, void* buffer_a, void* buffer_b, void* buffer_c, int B, int M, int N, int K);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_matmul_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_matmul_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int, c_int]
lib.execute_matmul_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_matmul_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0, 0)

print(f"Call to 'execute_matmul_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_mul_backward_on_gpu">
        <h2>execute_mul_backward_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dC</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_A</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_B</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dA</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dB</code></td></tr><tr><td><code>int</code></td><td><code>num_elements</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_mul_backward_on_gpu`<br /><br />#### Beschreibung<br />Diese Funktion führt den Backward-Pass für eine elementweise Multiplikation (`C = A * B`) auf der GPU aus. Sie berechnet die Gradienten `dA` und `dB` basierend auf dem eingehenden Gradienten der Ausgabe (`dC`) und den ursprünglichen Eingabe-Tensoren (`A` und `B`). Die durchgeführten Operationen sind `dA = dC * B` und `dB = dC * A`. Diese Funktion ist ein wesentlicher Bestandteil für das Training neuronaler Netze mittels Backpropagation.<br /><br />#### Anwendungshinweise<br />- Die OpenCL-Umgebung muss vor dem Aufruf dieser Funktion mit `initialize_opencl` initialisiert worden sein.<br />- Alle `void*` Parameter (`buffer_dC`, `buffer_A`, etc.) müssen gültige OpenCL-Speicherpuffer (`cl_mem`) sein, die zuvor auf der Ziel-GPU erstellt wurden.<br />- Alle fünf Puffer (`dC`, `A`, `B`, `dA`, `dB`) müssen die gleiche Größe haben: `num_elements * sizeof(float)`.<br />- `buffer_dA` und `buffer_dB` sind die Ausgabepuffer. Ihr Inhalt wird von der Funktion überschrieben.<br />- Die Funktion gibt `0` bei Erfolg und einen negativen Fehlercode bei einem Fehler zurück.<br /><br />#### Python ctypes Beispiel<br />Um diese Funktion über Python's `ctypes` aufzurufen, definieren Sie die `argtypes` für die geladene DLL. Ersetzen Sie im Code-Snippet die Zeiger auf Ihre `ctypes` Pufferobjekte (normalerweise `c_void_p`) und die ganzzahligen Werte (`c_int`) entsprechend den Funktionsparametern.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_mul_backward_on_gpu(int gpu_index, void* buffer_dC, void* buffer_A, void* buffer_B, void* buffer_dA, void* buffer_dB, int num_elements);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_mul_backward_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_mul_backward_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_void_p, c_void_p, c_int]
lib.execute_mul_backward_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_mul_backward_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_mul_backward_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_mul_on_gpu">
        <h2>execute_mul_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_a</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_b</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_c</code></td></tr><tr><td><code>int</code></td><td><code>num_elements</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_mul_on_gpu`<br /><br />#### Beschreibung<br /><br />Führt eine elementweise Multiplikation (Hadamard-Produkt) der Puffer `buffer_a` und `buffer_b` auf der angegebenen GPU aus. Das Ergebnis der Operation `C[i] = A[i] * B[i]` wird in `buffer_c` gespeichert. Diese Funktion ist optimiert für die parallele Berechnung auf einer großen Anzahl von Elementen, wie sie in numerischen Algorithmen und Machine-Learning-Anwendungen vorkommen.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzungen:** Der OpenCL-Kontext muss über `init_opencl` initialisiert sein. Alle drei Puffer müssen bereits auf der Ziel-GPU existieren (z. B. erstellt mit `create_buffer_on_gpu`).<br />*   **Puffergröße:** Die Puffer `buffer_a`, `buffer_b` und `buffer_c` müssen identische Größen haben, die mindestens `num_elements * sizeof(float)` Bytes umfassen.<br />*   **Datentyp:** Die Funktion operiert auf Puffern mit 32-Bit-Gleitkommazahlen (`float`).<br />*   **Synchronisation:** Der Aufruf ist blockierend (synchron). Nach erfolgreicher Rückkehr ist die Berechnung auf der GPU abgeschlossen und die Ergebnisse in `buffer_c` sind verfügbar (jedoch noch auf dem GPU-Speicher).<br />*   **Rückgabewert:** Gibt `0` bei Erfolg zurück. Ein Wert ungleich null signalisiert einen Fehlercode (z.B. ungültiger `gpu_index`, Fehler bei der Kernel-Ausführung).<br /><br />#### Hinweis zur Einbindung<br /><br />Im `ctypes`-Code-Snippet für Python müssen die Platzhalter für die Puffer (`buffer_a`, `buffer_b`, `buffer_c`) durch die tatsächlichen Pointer-Objekte der auf der GPU allokierten Puffer ersetzt werden. Der Parameter `num_elements` muss der Anzahl der Elemente in den Arrays entsprechen.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_mul_on_gpu(int gpu_index, void* buffer_a, void* buffer_b, void* buffer_c, int num_elements);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_mul_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_mul_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int]
lib.execute_mul_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_mul_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_mul_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_pairwise_similarity_gpu">
        <h2>execute_pairwise_similarity_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>states_nd</code></td></tr><tr><td><code>void*</code></td><td><code>output_similarity_nn</code></td></tr><tr><td><code>int</code></td><td><code>N</code></td></tr><tr><td><code>int</code></td><td><code>D</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_pairwise_similarity_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Berechnet die paarweise Ähnlichkeit zwischen einem Satz von N Vektoren auf der GPU. Die Funktion nimmt eine Eingabematrix der Größe `N x D` (`states_nd`) und erzeugt eine `N x N` Ähnlichkeitsmatrix (`output_similarity_nn`). Jeder Eintrag (i, j) in der Ausgabematrix repräsentiert die Ähnlichkeit zwischen dem i-ten und j-ten Eingabevektor. Dies ist nützlich für Aufgaben wie Nearest-Neighbor-Analysen oder zur Visualisierung von Einbettungsräumen.<br /><br />#### Anwendungshinweise<br /><br />*   Die Eingabe- (`states_nd`) und Ausgabe- (`output_similarity_nn`) Puffer müssen vor dem Aufruf dieser Funktion auf der GPU alloziert worden sein.<br />*   Der `states_nd`-Puffer muss eine Größe von `N * D * sizeof(float)` und der `output_similarity_nn`-Puffer eine Größe von `N * N * sizeof(float)` haben.<br />*   Die Daten in den Puffern werden als C-kontinuierlich (Row-Major) angenommen.<br />*   Gibt bei Erfolg `0` zurück. Ein Wert ungleich `0` signalisiert einen OpenCL-Fehler während der Kernel-Ausführung.<br />*   Der Aufrufer ist für die Verwaltung (Allokierung und Freigabe) der GPU-Puffer verantwortlich.<br /><br />#### Python `ctypes` Anbindung<br /><br />In einem Python-`ctypes`-Aufruf müssen die Platzhalter für die Puffer-Zeiger (`states_nd`, `output_similarity_nn`) und die Dimensionsgrößen (`N`, `D`) durch die entsprechenden Werte ersetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_pairwise_similarity_gpu(int gpu_index, void* states_nd, void* output_similarity_nn, int N, int D);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_pairwise_similarity_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_pairwise_similarity_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int, c_int]
lib.execute_pairwise_similarity_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_pairwise_similarity_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0)

print(f"Call to 'execute_pairwise_similarity_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_proto_segmented_sum_gpu">
        <h2>execute_proto_segmented_sum_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.bio</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>activations_flat</code></td></tr><tr><td><code>void*</code></td><td><code>indices_flat</code></td></tr><tr><td><code>void*</code></td><td><code>proto_sums</code></td></tr><tr><td><code>void*</code></td><td><code>proto_counts</code></td></tr><tr><td><code>int</code></td><td><code>num_elements_flat</code></td></tr><tr><td><code>int</code></td><td><code>E</code></td></tr><tr><td><code>int</code></td><td><code>T</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">Absolut. Hier ist die Dokumentation für die Funktion `execute_proto_segmented_sum_gpu`.<br /><br />---<br /><br />### `execute_proto_segmented_sum_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Diese Funktion führt eine segmentierte Summation auf der GPU durch. Sie aggregiert Vektoren aus dem `activations_flat`-Puffer basierend auf den zugehörigen Indizes in `indices_flat`. Diese Operation ist typisch für Prototypen-basierte Modelle im maschinellen Lernen, um die Aktivierungen für jeden Prototyp zu summieren und zu zählen.<br /><br />#### Anwendungshinweise<br /><br />- **Voraussetzungen:** Der GPU-Kontext muss mit `initialize_gpu` initialisiert worden sein.<br />- **Pufferspeicher:** Alle Zeiger (`activations_flat`, `indices_flat`, `proto_sums`, `proto_counts`) müssen auf Speicherpuffer verweisen, die zuvor auf der Ziel-GPU über `allocate_buffer_gpu` oder eine ähnliche Funktion alloziert wurden.<br />- **Initialisierung:** Die Ausgabepuffer `proto_sums` und `proto_counts` müssen vor dem Aufruf explizit auf Null gesetzt werden (z. B. mit `memset_buffer_gpu`), da der Kernel atomare Additionsoperationen durchführt und die Puffer nicht intern initialisiert.<br />- **Puffergrößen:**<br />    - `activations_flat`: Muss mindestens `num_elements_flat * E * sizeof(float)` Bytes groß sein.<br />    - `indices_flat`: Muss mindestens `num_elements_flat * sizeof(int)` Bytes groß sein.<br />    - `proto_sums`: Muss mindestens `T * E * sizeof(float)` Bytes groß sein.<br />    - `proto_counts`: Muss mindestens `T * sizeof(int)` Bytes groß sein.<br />- **Rückgabewert:** Gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehler (z.B. `-1` für einen ungültigen `gpu_index` oder `-2` für einen OpenCL-Fehler).<br /><br />#### Python `ctypes` Integration<br /><br />Für die Anbindung über `ctypes` in Python ersetzen Sie die Platzhalter im Funktionsaufruf. Übergeben Sie die `.value`-Eigenschaft Ihrer `cl_mem`-Objekte für die Puffer-Zeiger (`activations_flat`, `indices_flat`, etc.) und die entsprechenden Python-Integer-Variablen für die Größenparameter `num_elements_flat`, `E` und `T`.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_proto_segmented_sum_gpu(int gpu_index, void* activations_flat, void* indices_flat, void* proto_sums, void* proto_counts, int num_elements_flat, int E, int T);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_proto_segmented_sum_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_proto_segmented_sum_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int]
lib.execute_proto_segmented_sum_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_proto_segmented_sum_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0)

print(f"Call to 'execute_proto_segmented_sum_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_proto_update_step_gpu">
        <h2>execute_proto_update_step_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.bio</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>prototypes</code></td></tr><tr><td><code>void*</code></td><td><code>proto_sums</code></td></tr><tr><td><code>void*</code></td><td><code>proto_counts</code></td></tr><tr><td><code>float</code></td><td><code>learning_rate</code></td></tr><tr><td><code>int</code></td><td><code>E</code></td></tr><tr><td><code>int</code></td><td><code>T</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_proto_update_step_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt einen einzelnen Aktualisierungsschritt für Prototypen-Vektoren direkt auf der GPU durch. Diese Funktion wird in iterativen, prototypenbasierten Lernalgorithmen (z. B. LVQ, k-Means) eingesetzt, um die Prototypen basierend auf den in einem Batch akkumulierten Summen (`proto_sums`) und Zählern (`proto_counts`) anzupassen. Die Berechnung nutzt eine Lernrate und erfolgt "in-place", um Datenübertragungen zwischen Host und Gerät zu vermeiden.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzung:** Der OpenCL-Kontext muss zuvor über `init_opencl` für den spezifizierten `gpu_index` initialisiert worden sein.<br />*   **Puffergrößen:** Die übergebenen Zeiger müssen auf GPU-Puffer verweisen, die mit den folgenden Mindestgrößen angelegt wurden:<br />    *   `prototypes`: `T * E * sizeof(float)`<br />    *   `proto_sums`: `T * E * sizeof(float)`<br />    *   `proto_counts`: `T * sizeof(float)`<br />*   **Datenfluss:** Die Funktion modifiziert den `prototypes`-Puffer direkt auf dem Gerät (in-place) unter Verwendung der Daten aus `proto_sums` und `proto_counts`.<br />*   **Rückgabewert:** Gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehler, meist einen OpenCL-Fehler oder ungültige Parameter.<br /><br />#### Python ctypes Anbindung<br /><br />Im Python-Code müssen die `void*` Typen durch `ctypes.c_void_p` ersetzt werden, die auf die `cl_mem` Handles der GPU-Puffer zeigen. Die Dimensionsparameter `E` und `T` sowie die Lernrate werden als reguläre Python-Zahlen übergeben.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_proto_update_step_gpu(int gpu_index, void* prototypes, void* proto_sums, void* proto_counts, float learning_rate, int E, int T);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_proto_update_step_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_proto_update_step_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_float, c_int, c_int]
lib.execute_proto_update_step_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_proto_update_step_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0.0, 0, 0)

print(f"Call to 'execute_proto_update_step_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_qaoa_gpu">
        <h2>execute_qaoa_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>int</code></td><td><code>num_qubits</code></td></tr><tr><td><code>int</code></td><td><code>p_layers</code></td></tr><tr><td><code>const float*</code></td><td><code>gammas</code></td></tr><tr><td><code>const float*</code></td><td><code>betas</code></td></tr><tr><td><code>int</code></td><td><code>num_parameters</code></td></tr><tr><td><code>const PauliZTerm*</code></td><td><code>cost_terms</code></td></tr><tr><td><code>int</code></td><td><code>num_cost_terms</code></td></tr><tr><td><code>float*</code></td><td><code>out_energy</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### execute_qaoa_gpu<br /><br />#### Beschreibung<br />Führt den QAOA-Algorithmus (Quantum Approximate Optimization Algorithm) auf der angegebenen GPU aus. Diese Funktion simuliert einen Quantenschaltkreis, um die erwartete Energie eines Kosten-Hamiltonians zu berechnen, der als Summe von Pauli-Z-Termen definiert ist. Sie wird typischerweise innerhalb einer klassischen Optimierungsschleife verwendet, um die optimalen `gamma`- und `beta`-Parameter zu finden.<br /><br />#### Anwendungshinweise<br />*   Die GPU muss vor dem Aufruf dieser Funktion mit `initialize_opencl` initialisiert worden sein.<br />*   Die Arrays `gammas` und `betas` müssen jeweils `p_layers` Elemente enthalten. Der Parameter `num_parameters` muss daher gleich `p_layers` sein.<br />*   Der `cost_terms`-Parameter ist ein Array von `PauliZTerm`-Strukturen, die in der aufrufenden Sprache (z.B. über `ctypes` in Python) entsprechend definiert sein müssen.<br />*   Der Parameter `out_energy` muss ein Zeiger auf einen einzelnen `float`-Wert sein, in den das Ergebnis geschrieben wird.<br />*   Gibt `0` bei Erfolg und einen negativen Fehlercode bei einem Fehler zurück (z.B. ungültiger GPU-Index, OpenCL-Fehler).<br /><br />#### Python (ctypes) Integration<br />Für die Verwendung mit `ctypes` müssen die Zeiger und Längen in der Funktionssignatur korrekt gesetzt werden. Passen Sie die Zeigertypen (z.B. `ctypes.POINTER(ctypes.c_float)` für `gammas`, `betas`, `out_energy` und `ctypes.POINTER(PauliZTerm)` für `cost_terms`) und die dazugehörigen Längenparameter (`num_parameters`, `num_cost_terms`) an die Größe Ihrer Daten an.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_qaoa_gpu(int gpu_index, int num_qubits, int p_layers,
                               const float* gammas, const float* betas, int num_parameters,
                               const PauliZTerm* cost_terms, int num_cost_terms,
                               float* out_energy);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_qaoa_gpu
from ctypes import *
from pathlib import Path

class PauliZTerm(Structure):
    _fields_ = [
        ('z_mask', c_uint64),
        ('coefficient', c_float)
    ]

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_qaoa_gpu.argtypes = [c_int, c_int, c_int, POINTER(c_float), POINTER(c_float), c_int, c_void_p, c_int, POINTER(c_float)]
lib.execute_qaoa_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_qaoa_gpu(0, 0, 0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, None  # TODO: provide a valid pointer/buffer, 0, None  # TODO: provide a valid pointer/buffer)

print(f"Call to 'execute_qaoa_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_qec_cycle_gpu">
        <h2>execute_qec_cycle_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>int</code></td><td><code>code_type</code></td></tr><tr><td><code>uint32_t</code></td><td><code>error_mask</code></td></tr><tr><td><code>float*</code></td><td><code>out_syndrome</code></td></tr><tr><td><code>int</code></td><td><code>syndrome_length</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### Funktion: execute_qec_cycle_gpu<br /><br />**Gruppe:** `kernel.quantum`<br /><br />#### Beschreibung<br />Führt einen einzelnen Zyklus eines Quantenfehlerkorrektur-Codes (QEC) auf einer spezifizierten GPU aus. Die Funktion simuliert das Ergebnis eines gegebenen Fehlerzustands (`error_mask`) und berechnet das entsprechende Fehler-Syndrom. Sie wird zur Analyse der Leistung von QEC-Protokollen unter verschiedenen Fehlerbedingungen eingesetzt.<br /><br />#### Anwendungshinweise<br />- Die GPU-Umgebung muss vor dem Aufruf dieser Funktion mit `initialize_opencl` initialisiert worden sein.<br />- Der Aufrufer ist für die Allokation des `out_syndrome`-Puffers verantwortlich. Die Größe des Puffers muss exakt `syndrome_length` entsprechen.<br />- Der Parameter `code_type` muss einem der vordefinierten, von der Bibliothek unterstützten QEC-Code-Typen entsprechen. Ein ungültiger Typ führt zu einem Fehler.<br />- Die `error_mask` ist eine Bitmaske, die simuliert, welche Qubits von einem Fehler betroffen sind. Jedes gesetzte Bit repräsentiert einen spezifischen Fehler auf einem Qubit gemäß der Code-Definition.<br />- Die Funktion gibt `0` bei Erfolg und einen negativen Fehlercode bei einem Problem zurück (z. B. ungültiger `gpu_index`, Initialisierungsfehler).<br /><br />#### Python `ctypes` Integration<br />Für die Verwendung mit Python's `ctypes` muss der `out_syndrome`-Parameter als Pointer auf ein `c_float`-Array (`POINTER(c_float)`) übergeben werden. Erstellen Sie dazu ein Array der korrekten `syndrome_length` und übergeben Sie es der Funktion. Der Parameter `syndrome_length` muss die Anzahl der Elemente im Array angeben.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_qec_cycle_gpu(int gpu_index, int code_type, uint32_t error_mask,
                                    float* out_syndrome, int syndrome_length);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_qec_cycle_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_qec_cycle_gpu.argtypes = [c_int, c_int, c_uint, POINTER(c_float), c_int]
lib.execute_qec_cycle_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_qec_cycle_gpu(0, 0, 0, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_qec_cycle_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_qml_classifier_gpu">
        <h2>execute_qml_classifier_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>int</code></td><td><code>num_qubits</code></td></tr><tr><td><code>const float*</code></td><td><code>feature_vector</code></td></tr><tr><td><code>int</code></td><td><code>num_features</code></td></tr><tr><td><code>const float*</code></td><td><code>parameters</code></td></tr><tr><td><code>int</code></td><td><code>num_parameters</code></td></tr><tr><td><code>float*</code></td><td><code>out_expectations</code></td></tr><tr><td><code>int</code></td><td><code>expectation_length</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">Absolut. Hier ist die Dokumentation für `execute_qml_classifier_gpu` im angeforderten Format.<br /><br />---<br /><br />### `execute_qml_classifier_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Diese Funktion führt einen Quanten-Machine-Learning (QML) Klassifikator auf einem spezifizierten GPU-Gerät aus. Sie simuliert einen parametrisierten Quantenschaltkreis, der einen Merkmalsvektor kodiert, und berechnet die Erwartungswerte der resultierenden Qubits. Die Funktion ist für die Inferenz mit einem vortrainierten QML-Modell konzipiert, bei dem sowohl Merkmale als auch trainierbare Parameter als Eingabe dienen.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzung:** Die GPU muss vor dem Aufruf dieser Funktion mit `initialize_gpu` initialisiert worden sein.<br />*   **Pufferallokation:** Der Ausgabepuffer `out_expectations` muss vom Aufrufer mit einer Größe von mindestens `expectation_length` Elementen alloziert werden.<br />*   **Eingabedaten:** Die Zeiger `feature_vector` und `parameters` müssen auf gültige, im Host-Speicher (RAM) allozierte Daten verweisen.<br />*   **Synchroner Aufruf:** Die Funktion ist blockierend. Sie kehrt erst zurück, nachdem die GPU-Berechnung abgeschlossen ist und die Ergebnisse in den `out_expectations`-Puffer kopiert wurden.<br />*   **GPU-Index:** Der `gpu_index` ist 0-basiert und muss einem gültigen, initialisierten Gerät entsprechen.<br />*   **Rückgabewert:** Gibt `0` bei Erfolg und einen negativen Fehlercode bei einem Fehler zurück (z. B. bei ungültigen Parametern oder einem OpenCL-Fehler).<br /><br />#### Python `ctypes` Integration<br /><br />In einem Python-Code-Snippet, das diese Funktion über `ctypes` aufruft, müssen die Platzhalter für die Zeiger (`feature_vector`, `parameters`, `out_expectations`) und die zugehörigen Längen (`num_features`, `num_parameters`, `expectation_length`) durch die tatsächlichen NumPy-Arrays (oder andere Puffer) und deren Größen ersetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_qml_classifier_gpu(int gpu_index, int num_qubits,
                                         const float* feature_vector, int num_features,
                                         const float* parameters, int num_parameters,
                                         float* out_expectations, int expectation_length);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_qml_classifier_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_qml_classifier_gpu.argtypes = [c_int, c_int, POINTER(c_float), c_int, POINTER(c_float), c_int, POINTER(c_float), c_int]
lib.execute_qml_classifier_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_qml_classifier_gpu(0, 0, None  # TODO: provide a valid pointer/buffer, 0, None  # TODO: provide a valid pointer/buffer, 0, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_qml_classifier_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_reduce_sum_gpu">
        <h2>execute_reduce_sum_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>in</code></td></tr><tr><td><code>void*</code></td><td><code>out</code></td></tr><tr><td><code>int</code></td><td><code>B</code></td></tr><tr><td><code>int</code></td><td><code>M</code></td></tr><tr><td><code>int</code></td><td><code>N</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_reduce_sum_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt eine Reduktionssumme auf der GPU für einen 3D-Tensor aus. Die Funktion summiert die Elemente entlang der letzten Dimension (N) und schreibt das Ergebnis in einen 2D-Ausgabetensor. Dies ist eine häufige Operation zur Aggregation von Features in Deep-Learning-Modellen.<br /><br />#### Anwendungshinweise<br /><br />*   Die GPU muss vor dem Aufruf dieser Funktion mit `initialize_gpu` initialisiert worden sein.<br />*   Der Eingabepuffer `in` muss eine Größe von `B * M * N * sizeof(float)` haben und die Daten im Row-Major-Format enthalten.<br />*   Der Ausgabepuffer `out` muss vorab alloziert werden und eine Größe von `B * M * sizeof(float)` haben.<br />*   Die Funktion kümmert sich intern um die Datenübertragung zum und vom GPU-Speicher.<br />*   Gibt `0` bei Erfolg zurück, andernfalls einen Fehlercode ungleich Null.<br /><br />#### Python `ctypes` Anbindung<br /><br />Für die Anbindung aus Python mit `ctypes` muss ein Funktionsaufruf wie folgt strukturiert werden. Ersetzen Sie `in_ptr` und `out_ptr` durch die Datenzeiger Ihrer NumPy-Arrays (z.B. `in_array.ctypes.data_as(c_void_p)`) und `B`, `M`, `N` durch die entsprechenden Dimensionen.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_reduce_sum_gpu(int gpu_index, void* in, void* out, int B, int M, int N);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_reduce_sum_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_reduce_sum_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int, c_int, c_int]
lib.execute_reduce_sum_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_reduce_sum_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0)

print(f"Call to 'execute_reduce_sum_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_shape_loss_with_reward_penalty_gpu">
        <h2>execute_shape_loss_with_reward_penalty_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>loss_per_sample_in</code></td></tr><tr><td><code>void*</code></td><td><code>predictions</code></td></tr><tr><td><code>void*</code></td><td><code>targets</code></td></tr><tr><td><code>void*</code></td><td><code>loss_per_sample_out</code></td></tr><tr><td><code>int</code></td><td><code>num_samples</code></td></tr><tr><td><code>int</code></td><td><code>num_classes</code></td></tr><tr><td><code>float</code></td><td><code>penalty_weight</code></td></tr><tr><td><code>float</code></td><td><code>reward_weight</code></td></tr><tr><td><code>float</code></td><td><code>high_confidence_threshold</code></td></tr><tr><td><code>int</code></td><td><code>critical_target_class</code></td></tr><tr><td><code>int</code></td><td><code>critical_predicted_class</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_shape_loss_with_reward_penalty_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Diese Funktion modifiziert einen vorab berechneten Loss-Wert für jedes Sample direkt auf der GPU. Sie wird für das "Loss Shaping" verwendet, um das Modelltraining gezielt zu beeinflussen. Dabei werden spezifische, als kritisch definierte Fehlklassifizierungen stärker bestraft und/oder korrekte Klassifizierungen kritischer Klassen belohnt, was hilft, besonders unerwünschte Fehler zu vermeiden.<br /><br />#### Anwendungshinweise<br /><br />- **Voraussetzungen:** Der OpenCL-Treiber muss mit `initialize_opencl_driver` initialisiert und ein gültiger `gpu_index` bereitgestellt werden. Alle Puffer (`loss_per_sample_in`, `predictions`, `targets`, `loss_per_sample_out`) müssen vor dem Aufruf auf der GPU alloziert sein.<br />- **Puffergrößen:** Die Größe der Puffer muss exakt den Dimensionen der Daten entsprechen:<br />    - `loss_per_sample_in` & `loss_per_sample_out`: `num_samples * sizeof(float)`<br />    - `predictions`: `num_samples * num_classes * sizeof(float)`<br />    - `targets`: `num_samples * sizeof(int)`<br />- **Datenfluss:** Die Funktion liest die ursprünglichen Loss-Werte aus `loss_per_sample_in` und schreibt die modifizierten Ergebnisse in den separaten Puffer `loss_per_sample_out`. Der Eingabepuffer bleibt unverändert.<br />- **Logik:** Eine Strafe (`penalty_weight`) wird angewendet, wenn ein Sample die Zielklasse `critical_target_class` hat, aber fälschlicherweise als `critical_predicted_class` mit einer Konfidenz über `high_confidence_threshold` klassifiziert wird. Eine Belohnung (`reward_weight`) wird für die korrekte Klassifizierung der `critical_target_class` vergeben.<br />- **Rückgabewert:** Gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehler, z. B. bei der Kernel-Ausführung oder bei ungültigen Parametern.<br /><br />#### Hinweis zur Ctypes-Integration<br /><br />In einem Python-Wrapper mit `ctypes` müssen die `void*`-Parameter durch die entsprechenden GPU-Puffer-Pointer (z. B. `ctypes.c_void_p`) ersetzt werden. Die Größenparameter wie `num_samples` und `num_classes` müssen mit den korrekten Dimensionen Ihrer Numpy-Arrays oder Tensoren übereinstimmen.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_shape_loss_with_reward_penalty_gpu(int gpu_index, void* loss_per_sample_in, void* predictions, void* targets, void* loss_per_sample_out, int num_samples, int num_classes, float penalty_weight, float reward_weight, float high_confidence_threshold, int critical_target_class, int critical_predicted_class);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_shape_loss_with_reward_penalty_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_shape_loss_with_reward_penalty_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_void_p, c_int, c_int, c_float, c_float, c_float, c_int, c_int]
lib.execute_shape_loss_with_reward_penalty_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_shape_loss_with_reward_penalty_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0.0, 0.0, 0.0, 0, 0)

print(f"Call to 'execute_shape_loss_with_reward_penalty_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_shape_loss_with_reward_penalty_list_gpu">
        <h2>execute_shape_loss_with_reward_penalty_list_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>loss_per_sample_in</code></td></tr><tr><td><code>void*</code></td><td><code>predictions</code></td></tr><tr><td><code>void*</code></td><td><code>targets</code></td></tr><tr><td><code>void*</code></td><td><code>loss_per_sample_out</code></td></tr><tr><td><code>void*</code></td><td><code>critical_pairs</code></td></tr><tr><td><code>int</code></td><td><code>num_samples</code></td></tr><tr><td><code>int</code></td><td><code>num_classes</code></td></tr><tr><td><code>int</code></td><td><code>num_critical_pairs</code></td></tr><tr><td><code>float</code></td><td><code>penalty_weight</code></td></tr><tr><td><code>float</code></td><td><code>reward_weight</code></td></tr><tr><td><code>float</code></td><td><code>high_confidence_threshold</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_shape_loss_with_reward_penalty_list_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Berechnet eine modifizierte Loss-Funktion ("Shape Loss") auf der GPU, die einen bestehenden Loss-Wert gezielt anpasst. Die Funktion nutzt eine Liste von "kritischen Paaren" von Klassen, um Fehlklassifizierungen zwischen diesen spezifischen Paaren zu bestrafen und korrekte, hochsichere Vorhersagen zu belohnen. Dies ist nützlich, um die Trennschärfe eines Modells zwischen häufig verwechselten Klassen zu verbessern.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzung:** Der OpenCL-Kontext für den angegebenen `gpu_index` muss bereits initialisiert sein.<br />*   **Puffergrößen:**<br />    *   `loss_per_sample_in`, `loss_per_sample_out`, `targets`: Müssen die Länge `num_samples` haben.<br />    *   `predictions`: Muss ein 2D-Array der Größe `num_samples * num_classes` sein (als 1D-Array abgeflacht).<br />    *   `critical_pairs`: Muss ein 2D-Array der Größe `num_critical_pairs * 2` sein (als 1D-Array abgeflacht).<br />*   **Datentypen:**<br />    *   `float` Puffer: `loss_per_sample_in`, `predictions`, `loss_per_sample_out`.<br />    *   `int` Puffer: `targets`, `critical_pairs`.<br />*   **Ausführung:** Der Kernel-Aufruf ist asynchron. Falls das Ergebnis sofort benötigt wird, muss die Synchronisation manuell (z.B. durch `clFinish`) erfolgen.<br />*   **Rückgabewert:** Gibt `0` bei Erfolg oder einen Fehlercode ungleich Null zurück.<br /><br />#### Python `ctypes` Integration<br /><br />Für die Anbindung via Python `ctypes` müssen die `void*`-Argumente als Pointer auf die entsprechenden NumPy-Arrays übergeben werden. Passen Sie die Längen- und Dimensionsparameter (`num_samples`, `num_classes` usw.) sowie die Skalarwerte an die Dimensionen Ihrer Daten an.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_shape_loss_with_reward_penalty_list_gpu(int gpu_index, void* loss_per_sample_in, void* predictions, void* targets, void* loss_per_sample_out, void* critical_pairs, int num_samples, int num_classes, int num_critical_pairs, float penalty_weight, float reward_weight, float high_confidence_threshold);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_shape_loss_with_reward_penalty_list_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_shape_loss_with_reward_penalty_list_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_void_p, c_void_p, c_int, c_int, c_int, c_float, c_float, c_float]
lib.execute_shape_loss_with_reward_penalty_list_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_shape_loss_with_reward_penalty_list_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0, 0.0, 0.0, 0.0)

print(f"Call to 'execute_shape_loss_with_reward_penalty_list_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_shor_gpu">
        <h2>execute_shor_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>int</code></td><td><code>modulus_N</code></td></tr><tr><td><code>int</code></td><td><code>base_a</code></td></tr><tr><td><code>int*</code></td><td><code>out_period_estimate</code></td></tr><tr><td><code>float*</code></td><td><code>out_control_distribution</code></td></tr><tr><td><code>int</code></td><td><code>distribution_length</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `kernel.quantum.execute_shor_gpu`<br /><br />#### Beschreibung<br /><br />Führt den rechenintensiven Quantenteil des Shor-Algorithmus auf einem angegebenen OpenCL-Gerät aus. Die Funktion berechnet eine Schätzung für die Periode `r` der modularen Exponentiationsfunktion `f(x) = a^x mod N`, die für die Faktorisierung von `N` benötigt wird. Sie gibt sowohl die geschätzte Periode als auch die resultierende Wahrscheinlichkeitsverteilung des Kontrollregisters nach der Quanten-Fourier-Transformation zurück.<br /><br />#### Anmerkungen zur Nutzung<br /><br />*   Ein gültiger OpenCL-Kontext muss vor dem Aufruf dieser Funktion initialisiert worden sein.<br />*   Die Eingabewerte `modulus_N` und `base_a` müssen teilerfremd sein (`ggT(a, N) = 1`).<br />*   Der Aufrufer muss den Speicher für die Ausgabeparameter `out_period_estimate` (ein einzelner `int`) und `out_control_distribution` (ein `float`-Array) vorab alloziieren.<br />*   Die Größe des `out_control_distribution`-Puffers, `distribution_length`, muss ausreichend groß sein, typischerweise eine Zweierpotenz, die mindestens `2*N` ist.<br />*   Die Funktion gibt `0` bei Erfolg und einen negativen Fehlercode im Fehlerfall zurück (z.B. `ERR_INVALID_GPU_INDEX`, `ERR_OPENCL_ERROR`).<br /><br />#### Python (ctypes) Beispiel<br /><br />Das folgende Snippet zeigt, wie die Funktion mittels `ctypes` aus Python aufgerufen wird. Ersetzen Sie die Platzhalter (`_DLL_PATH_`, `_GPU_INDEX_`, etc.) durch Ihre konkreten Werte. Die Puffer für die Ausgabewerte (`period` und `distribution_array`) werden in Python erstellt und als Zeiger an die Funktion übergeben.<br /><br />```python<br />import ctypes<br /><br /># Laden der DLL<br />dll_path = r"_DLL_PATH_"<br />lib = ctypes.CDLL(dll_path)<br /><br /># Definition des Funktionsprototyps<br />execute_shor_gpu = lib.execute_shor_gpu<br />execute_shor_gpu.restype = ctypes.c_int<br />execute_shor_gpu.argtypes = [<br />    ctypes.c_int,<br />    ctypes.c_int,<br />    ctypes.c_int,<br />    ctypes.POINTER(ctypes.c_int),<br />    ctypes.POINTER(ctypes.c_float),<br />    ctypes.c_int<br />]<br /><br /># --- Ersetzen Sie die Platzhalter durch Ihre Werte ---<br />gpu_index = _GPU_INDEX_           # z.B. 0<br />modulus_N = _MODULUS_N_           # z.B. 15<br />base_a = _BASE_A_                 # z.B. 7<br />distribution_length = _DISTRIBUTION_LENGTH_ # z.B. 2048<br /><br /># Vorbereiten der Ausgabeparameter<br />period = ctypes.c_int()<br />distribution_array = (ctypes.c_float * distribution_length)()<br /><br /># Funktionsaufruf<br />result = execute_shor_gpu(<br />    gpu_index,<br />    modulus_N,<br />    base_a,<br />    ctypes.byref(period),<br />    distribution_array,<br />    distribution_length<br />)<br /><br /># Ergebnisse prüfen und ausgeben<br />if result == 0:<br />    print(f"Erfolgreich ausgeführt.")<br />    print(f"Geschätzte Periode (r): {period.value}")<br />    # Die ersten 10 Werte der Verteilung anzeigen<br />    print(f"Verteilung (erste 10 Werte): {[f'{x:.4f}' for x in distribution_array[:10]]}")<br />else:<br />    print(f"Fehler beim Ausführen, Code: {result}")<br /><br />```</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_shor_gpu(int gpu_index, int modulus_N, int base_a,
                               int* out_period_estimate,
                               float* out_control_distribution, int distribution_length);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_shor_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_shor_gpu.argtypes = [c_int, c_int, c_int, POINTER(c_int), POINTER(c_float), c_int]
lib.execute_shor_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_shor_gpu(0, 0, 0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'execute_shor_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_softmax_backward_on_gpu">
        <h2>execute_softmax_backward_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.softmax</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dy</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_y</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dx</code></td></tr><tr><td><code>int</code></td><td><code>num_rows</code></td></tr><tr><td><code>int</code></td><td><code>row_size</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_softmax_backward_on_gpu`<br /><br />#### Beschreibung<br /><br />Diese Funktion führt die Rückwärtspropagation (Backward Pass) für die Softmax-Funktion auf einer angegebenen GPU aus. Sie berechnet den Gradienten `dx` basierend auf dem vorgeschalteten Gradienten `dy` und der ursprünglichen Softmax-Ausgabe `y`. Diese Operation ist ein grundlegender Schritt beim Training von neuronalen Netzen.<br /><br />#### Anwendungshinweise<br /><br />-   **Voraussetzung:** Der OpenCL-Kontext muss zuvor mit `init_opencl` für den `gpu_index` initialisiert worden sein.<br />-   **Puffer-Allokation:** Die Puffer `buffer_dy`, `buffer_y` und `buffer_dx` müssen bereits als `cl_mem` Objekte auf der Ziel-GPU mittels `create_buffer_on_gpu` existieren.<br />-   **Puffergrößen:** Alle drei Puffer müssen die gleiche Größe haben, die sich aus `num_rows * row_size * sizeof(float)` ergibt.<br />-   **Datenfluss:** `buffer_dy` und `buffer_y` sind Eingabepuffer. Der berechnete Gradient wird in den Ausgabepuffer `buffer_dx` geschrieben.<br />-   **Rückgabewert:** Die Funktion gibt `0` bei Erfolg oder einen negativen Fehlercode bei einem Fehler zurück.<br /><br />#### Python ctypes Snippet<br /><br />Das folgende Snippet zeigt, wie die Funktion über `ctypes` aufgerufen wird. Ersetzen Sie die Platzhalter (`<...>`) durch Ihre tatsächlichen Variablen.<br /><br />```python<br />import ctypes<br /><br /># Annahme: 'dll' ist das geladene CipherCore_OpenCl.dll Objekt<br /># Annahme: Puffer (dy_ptr, y_ptr, dx_ptr) wurden bereits auf der GPU erstellt<br /><br /># Funktions-Prototyp definieren<br />dll.execute_softmax_backward_on_gpu.argtypes = [<br />    ctypes.c_int,<br />    ctypes.c_void_p,<br />    ctypes.c_void_p,<br />    ctypes.c_void_p,<br />    ctypes.c_int,<br />    ctypes.c_int<br />]<br />dll.execute_softmax_backward_on_gpu.restype = ctypes.c_int<br /><br /># Funktionsaufruf mit Platzhaltern<br />result = dll.execute_softmax_backward_on_gpu(<br />    <gpu_index>,<br />    <ctypes_pointer_to_dy>,<br />    <ctypes_pointer_to_y>,<br />    <ctypes_pointer_to_dx>,<br />    <num_rows>,<br />    <row_size><br />)<br /><br />if result != 0:<br />    print(f"Fehler bei der Ausführung des Softmax-Backward-Kerns: {result}")<br /><br />```<br /><br />**Hinweis:** Ersetzen Sie `<ctypes_pointer_to_dy>`, `<ctypes_pointer_to_y>` und `<ctypes_pointer_to_dx>` durch die tatsächlichen `ctypes.c_void_p` Zeiger auf Ihre GPU-Puffer sowie die Dimensions- und Index-Parameter entsprechend.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_softmax_backward_on_gpu(int gpu_index, void* buffer_dy, void* buffer_y, void* buffer_dx, int num_rows, int row_size);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_softmax_backward_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_softmax_backward_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_void_p, c_int, c_int]
lib.execute_softmax_backward_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_softmax_backward_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0)

print(f"Call to 'execute_softmax_backward_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_softmax_on_gpu">
        <h2>execute_softmax_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.softmax</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_input</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_output</code></td></tr><tr><td><code>int</code></td><td><code>num_rows</code></td></tr><tr><td><code>int</code></td><td><code>row_size</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### execute_softmax_on_gpu<br /><br />#### Kurzbeschreibung<br /><br />Führt die Softmax-Funktion zeilenweise auf einer Matrix aus, die auf einer bestimmten GPU verarbeitet wird. Die Funktion transformiert jede Zeile von numerischen Werten (Logits) in eine Wahrscheinlichkeitsverteilung. Sie wird typischerweise in den Ausgabeschichten von neuronalen Netzen für Klassifikationsaufgaben verwendet.<br /><br />#### Anwendungshinweise<br /><br />-   Der `gpu_index` muss auf eine gültige, OpenCL-fähige GPU verweisen (0-basierter Index).<br />-   `buffer_input` und `buffer_output` müssen vom Aufrufer alloziert und auch wieder freigegeben werden.<br />-   Beide Puffer müssen dieselbe Größe haben: `num_rows * row_size * sizeof(float)`. Die Funktion erwartet 32-Bit-Gleitkommazahlen (`float`).<br />-   Die Eingabedaten werden als eine 2D-Matrix im Row-Major-Format behandelt, die in einem zusammenhängenden 1D-Puffer gespeichert ist.<br />-   Gibt bei Erfolg `0` zurück. Ein negativer Wert signalisiert einen Fehler, z. B. einen ungültigen GPU-Index oder einen Fehler bei der OpenCL-Kernel-Ausführung.<br /><br />#### Python ctypes Beispiel<br /><br />Im Python-`ctypes`-Code-Snippet müssen die Platzhalter für `buffer_input`, `buffer_output`, `num_rows` und `row_size` durch die tatsächlichen ctypes-Pointer zu Ihren Datenpuffern und die entsprechenden Integer-Werte ersetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_softmax_on_gpu(int gpu_index, void* buffer_input, void* buffer_output, int num_rows, int row_size);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_softmax_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_softmax_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int, c_int]
lib.execute_softmax_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_softmax_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0)

print(f"Call to 'execute_softmax_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_threshold_spike_on_gpu">
        <h2>execute_threshold_spike_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_activations</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_spikes</code></td></tr><tr><td><code>float</code></td><td><code>threshold</code></td></tr><tr><td><code>int</code></td><td><code>num_elements</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_threshold_spike_on_gpu`<br /><br />#### Beschreibung<br />Führt eine Schwellenwert-Operation auf einem GPU-Puffer aus, um binäre "Spikes" zu erzeugen. Für jedes Element im Eingabepuffer `buffer_activations`, das den `threshold` (Schwellenwert) überschreitet, wird das entsprechende Element im Ausgabepuffer `buffer_spikes` auf 1.0 gesetzt, andernfalls auf 0.0. Diese Funktion wird typischerweise in Spiking Neural Networks (SNNs) verwendet, um kontinuierliche Aktivierungswerte in binäre Signale umzuwandeln.<br /><br />#### Anwendungshinweise<br />- **Voraussetzungen:** Der OpenCL-Kontext muss über `init_opencl` für den angegebenen `gpu_index` initialisiert sein.<br />- **Puffer:** `buffer_activations` (Eingabe) und `buffer_spikes` (Ausgabe) müssen zuvor auf der GPU (z.B. via `create_buffer`) alloziert worden sein und die gleiche Größe haben. Beide Puffer müssen für `float`-Werte ausgelegt sein.<br />- **Größe:** Die Größe beider Puffer muss mindestens `num_elements * sizeof(float)` Bytes betragen.<br />- **GPU-Index:** Der `gpu_index` muss ein gültiger Index eines initialisierten Geräts sein.<br />- **Rückgabewert:** Gibt `0` bei Erfolg zurück. Ein Wert ungleich null signalisiert einen Fehler, z.B. einen ungültigen GPU-Index oder einen Fehler bei der Kernel-Ausführung.<br /><br />#### Python ctypes Beispiel<br />```python<br />import ctypes<br /><br /># Annahme: 'lib' ist die geladene DLL/SO und die Puffer-Pointer existieren<br /># ...<br /><br /># Prototyp definieren<br />execute_threshold_spike_on_gpu = lib.execute_threshold_spike_on_gpu<br />execute_threshold_spike_on_gpu.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int]<br />execute_threshold_spike_on_gpu.restype = ctypes.c_int<br /><br /># Aufruf<br /># Ersetzen Sie die Platzhalter durch Ihre ctypes-Zeiger und Variablen<br />gpu_index = 0<br />activations_ptr = ..._activations_ptr  # ctypes.c_void_p<br />spikes_ptr = ..._spikes_ptr            # ctypes.c_void_p<br />threshold = ..._threshold              # float<br />num_elements = ..._num_elements        # int<br /><br />result = execute_threshold_spike_on_gpu(gpu_index, activations_ptr, spikes_ptr, threshold, num_elements)<br /><br />if result != 0:<br />    print(f"Fehler bei der Ausführung des Threshold-Spike-Kernels auf GPU {gpu_index}")<br />```<br />*Ersetzen Sie `..._activations_ptr`, `..._spikes_ptr`, `..._threshold` und `..._num_elements` durch Ihre tatsächlichen ctypes-Zeiger und Variablen.*</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_threshold_spike_on_gpu(int gpu_index, void* buffer_activations, void* buffer_spikes, float threshold, int num_elements);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_threshold_spike_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_threshold_spike_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_float, c_int]
lib.execute_threshold_spike_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_threshold_spike_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0.0, 0)

print(f"Call to 'execute_threshold_spike_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_transpose_12_batched_gpu">
        <h2>execute_transpose_12_batched_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_in</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_out</code></td></tr><tr><td><code>int</code></td><td><code>B</code></td></tr><tr><td><code>int</code></td><td><code>D1</code></td></tr><tr><td><code>int</code></td><td><code>D2</code></td></tr><tr><td><code>int</code></td><td><code>D3</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_transpose_12_batched_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt eine batched Transponierung auf der GPU durch, bei der die Achsen 1 und 2 eines 4D-Tensors vertauscht werden. Diese Funktion transformiert einen Eingabe-Tensor mit der Form `(B, D1, D2, D3)` in einen Ausgabe-Tensor mit der Form `(B, D2, D1, D3)`. Sie wird typischerweise in neuronalen Netzen verwendet, um die Datenanordnung für nachfolgende Operationen wie Faltungen oder Aufmerksamkeitsmechanismen anzupassen.<br /><br />#### Hinweise zur Verwendung<br /><br />*   **Voraussetzung:** Die GPU mit dem angegebenen `gpu_index` muss vor dem Aufruf dieser Funktion initialisiert worden sein.<br />*   **Puffer-Allokation:** Die Puffer `buffer_in` und `buffer_out` müssen vorab auf der Ziel-GPU alloziert werden.<br />*   **Puffergröße:** Die Größe beider Puffer muss `B * D1 * D2 * D3 * sizeof(float)` betragen.<br />*   **Datenfluss:** Die Eingabedaten müssen vor dem Aufruf in den `buffer_in` kopiert werden. Das Ergebnis wird in `buffer_out` geschrieben.<br />*   **Fehlercodes:** Die Funktion gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehlercode des OpenCL-Treibers.<br /><br />#### Python `ctypes` Beispiel<br /><br />Der folgende Codeausschnitt zeigt, wie die Funktion über `ctypes` aufgerufen wird. Ersetzen Sie die Platzhalter durch Ihre GPU-Puffer-Zeiger und die spezifischen Tensor-Dimensionen.<br /><br />```python<br />import ctypes<br /><br /># DLL laden (Beispiel für Windows)<br />lib = ctypes.CDLL("CipherCore_OpenCl.dll")<br /><br /># Funktionsprototyp definieren<br /># int execute_transpose_12_batched_gpu(int gpu_index, void* buffer_in, void* buffer_out, int B, int D1, int D2, int D3);<br />lib.execute_transpose_12_batched_gpu.argtypes = [<br />    ctypes.c_int,<br />    ctypes.c_void_p,<br />    ctypes.c_void_p,<br />    ctypes.c_int,<br />    ctypes.c_int,<br />    ctypes.c_int,<br />    ctypes.c_int<br />]<br />lib.execute_transpose_12_batched_gpu.restype = ctypes.c_int<br /><br /># --- Platzhalter ersetzen ---<br />gpu_index = 0<br /># Annahme: gpu_buffer_in und gpu_buffer_out sind ctypes.c_void_p Zeiger<br /># auf bereits auf der GPU alloziierten Speicher.<br />gpu_buffer_in = ctypes.c_void_p(...)<br />gpu_buffer_out = ctypes.c_void_p(...)<br />B, D1, D2, D3 = 64, 128, 512, 16<br /># --------------------------<br /><br /># Funktion aufrufen<br />result = lib.execute_transpose_12_batched_gpu(<br />    gpu_index,<br />    gpu_buffer_in,<br />    gpu_buffer_out,<br />    B,<br />    D1,<br />    D2,<br />    D3<br />)<br /><br />if result != 0:<br />    print(f"Fehler bei der Ausführung des Transpose-Kernels, Code: {result}")<br />```</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_transpose_12_batched_gpu(int gpu_index, void* buffer_in, void* buffer_out, int B, int D1, int D2, int D3);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_transpose_12_batched_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_transpose_12_batched_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int, c_int, c_int, c_int]
lib.execute_transpose_12_batched_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_transpose_12_batched_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0, 0)

print(f"Call to 'execute_transpose_12_batched_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_transpose_backward_on_gpu">
        <h2>execute_transpose_backward_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dC</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_dA</code></td></tr><tr><td><code>int</code></td><td><code>rows_A</code></td></tr><tr><td><code>int</code></td><td><code>cols_A</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_transpose_backward_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Diese Funktion führt die Gradientenberechnung (Rückwärtspropagation) für eine Matrix-Transponierungsoperation auf der GPU aus. Sie wird typischerweise während des Trainings von neuronalen Netzen verwendet, wenn im Vorwärtsdurchlauf eine Transponierung (`C = A^T`) stattgefunden hat. Die Funktion berechnet den Gradienten bezüglich der ursprünglichen Matrix `A` durch Transponieren des eingehenden Gradienten `dC`.<br /><br />#### Verwendungshinweise<br /><br />*   **Voraussetzung:** Die Ziel-GPU muss zuvor mit `initialize_gpu` initialisiert worden sein.<br />*   **Buffer-Allokation:** Die Buffer `buffer_dC` (Eingabe) und `buffer_dA` (Ausgabe) müssen vor dem Aufruf dieser Funktion auf der GPU alloziert werden.<br />*   **Buffer-Größe:** Beide Buffer müssen ausreichend Speicher für `rows_A * cols_A` Elemente vom Typ `float` bereitstellen.<br />*   **Datenfluss:** `buffer_dC` enthält den Gradienten von der nachfolgenden Schicht. Das Ergebnis, der Gradient für die vorherige Schicht, wird in `buffer_dA` geschrieben.<br />*   **Rückgabewert:** Die Funktion gibt `0` bei Erfolg oder einen Fehlercode bei einem Problem zurück.<br /><br />#### Python ctypes Beispiel<br /><br />Das folgende Snippet zeigt, wie die Funktion über `ctypes` in Python aufgerufen wird.<br /><br />```python<br />import ctypes<br /><br /># Lade die DLL<br />lib = ctypes.CDLL("CipherCore_OpenCl.dll")<br /><br /># Definiere den Funktionsprototyp<br />execute_transpose_backward_on_gpu = lib.execute_transpose_backward_on_gpu<br />execute_transpose_backward_on_gpu.argtypes = [<br />    ctypes.c_int,      # gpu_index<br />    ctypes.c_void_p,   # buffer_dC<br />    ctypes.c_void_p,   # buffer_dA<br />    ctypes.c_int,      # rows_A<br />    ctypes.c_int       # cols_A<br />]<br />execute_transpose_backward_on_gpu.restype = ctypes.c_int<br /><br /># --- Beispielaufruf ---<br /># Ersetzen Sie die Platzhalter durch Ihre tatsächlichen Werte.<br /># ptr_dC und ptr_dA müssen die von der GPU-Allokationsfunktion<br /># zurückgegebenen Pointer sein.<br />gpu_idx = 0<br />rows_A = 128<br />cols_A = 256<br />ptr_dC = ctypes.c_void_p(your_dC_buffer_pointer) # z.B. von create_buffer_on_gpu<br />ptr_dA = ctypes.c_void_p(your_dA_buffer_pointer) # z.B. von create_buffer_on_gpu<br /><br />result = execute_transpose_backward_on_gpu(<br />    gpu_idx,<br />    ptr_dC,<br />    ptr_dA,<br />    rows_A,<br />    cols_A<br />)<br /><br />if result != 0:<br />    print(f"Fehler bei der Ausführung des Transpose-Backward-Kernels: {result}")<br /><br />```</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_transpose_backward_on_gpu(int gpu_index, void* buffer_dC, void* buffer_dA, int rows_A, int cols_A);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_transpose_backward_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_transpose_backward_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int, c_int]
lib.execute_transpose_backward_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_transpose_backward_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0)

print(f"Call to 'execute_transpose_backward_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_transpose_batched_gpu">
        <h2>execute_transpose_batched_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>in</code></td></tr><tr><td><code>void*</code></td><td><code>out</code></td></tr><tr><td><code>int</code></td><td><code>B_flat</code></td></tr><tr><td><code>int</code></td><td><code>d1</code></td></tr><tr><td><code>int</code></td><td><code>d2</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_transpose_batched_gpu`<br /><br />#### Beschreibung<br />Führt eine gestapelte (batched) Matrixtransposition auf der angegebenen GPU aus. Die Funktion nimmt einen Stapel von `B_flat` Matrizen der Dimension `d1 x d2` entgegen und schreibt die transponierten Matrizen der Dimension `d2 x d1` in den Ausgabe-Buffer. Dies ist nützlich für Operationen in neuronalen Netzen, die eine Änderung des Datenlayouts erfordern.<br /><br />#### Anwendungshinweise<br />- Die GPU muss vor dem Aufruf mit `initialize_gpu` initialisiert worden sein.<br />- Die Eingabe- (`in`) und Ausgabe- (`out`) Buffer müssen vorab alloziert werden. Die erforderliche Größe beträgt `B_flat * d1 * d2 * sizeof(float)` Bytes.<br />- Die Operation wird nicht "in-place" ausgeführt; `in` und `out` müssen auf unterschiedliche Speicherbereiche zeigen.<br />- Die Funktion erwartet, dass die Daten in den Buffern als 32-Bit-Gleitkommazahlen (`float`) vorliegen.<br />- Gibt `0` bei Erfolg zurück, andernfalls einen Fehlercode ungleich Null (z.B. bei ungültigem `gpu_index` oder einem Fehler bei der Kernel-Ausführung).<br /><br />#### Python `ctypes` Integration<br />Im Python `ctypes`-Wrapper müssen für die Parameter `in` und `out` Pointer zu den Daten-Buffern übergeben werden (z.B. aus den `.ctypes.data`-Attributen von NumPy-Arrays). Die Integer-Parameter `B_flat`, `d1` und `d2` müssen den Dimensionen der Daten entsprechen.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_transpose_batched_gpu(int gpu_index, void* in, void* out, int B_flat, int d1, int d2);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_transpose_batched_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_transpose_batched_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int, c_int, c_int]
lib.execute_transpose_batched_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_transpose_batched_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0, 0)

print(f"Call to 'execute_transpose_batched_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_transpose_on_gpu">
        <h2>execute_transpose_on_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.misc</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_input</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_output</code></td></tr><tr><td><code>int</code></td><td><code>rows</code></td></tr><tr><td><code>int</code></td><td><code>cols</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `execute_transpose_on_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Führt eine Matrix-Transponierung auf einem angegebenen GPU-Gerät durch. Die Funktion liest eine Eingabematrix der Dimension `rows x cols` und schreibt das Ergebnis, eine transponierte Matrix der Dimension `cols x rows`, in einen separaten Ausgabepuffer. Diese Operation ist fundamental für lineare Algebra und wird häufig zur Umstrukturierung von Daten in KI-Anwendungen benötigt.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzung:** Die OpenCL-Umgebung muss zuvor mit `initialize_opencl()` erfolgreich initialisiert worden sein.<br />*   **GPU-Index:** Der `gpu_index` muss ein gültiger, initialisierter Index eines verfügbaren Geräts sein.<br />*   **Puffer:** `buffer_input` und `buffer_output` müssen auf dem Host allozierte Speicherpuffer sein, die sich nicht überlappen dürfen.<br />*   **Puffergröße:** Beide Puffer müssen ausreichend groß sein, um `rows * cols` Elemente vom Typ `float` aufzunehmen. Die Funktion operiert intern ausschließlich mit 32-Bit-Gleitkommazahlen.<br />*   **Rückgabewert:** Gibt `0` bei Erfolg oder einen negativen Fehlercode bei einem Problem zurück (z.B. ungültiger Index, OpenCL-Fehler).<br /><br />#### Python ctypes Beispiel<br /><br />Im folgenden `ctypes`-Snippet müssen die Platzhalter durch Zeiger auf Ihre NumPy-Arrays sowie die korrekten Dimensionswerte ersetzt werden.<br /><br />```python<br /># Annahmen:<br /># - 'lib' ist die geladene DLL/SO-Datei.<br /># - 'input_array' und 'output_array' sind NumPy-Arrays des Typs np.float32.<br /># - 'gpu_idx', 'num_rows', 'num_cols' sind definierte Variablen.<br /><br />lib.execute_transpose_on_gpu(<br />    gpu_idx,<br />    ctypes.c_void_p(input_array.ctypes.data),<br />    ctypes.c_void_p(output_array.ctypes.data),<br />    num_rows,<br />    num_cols<br />)<br />```</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_transpose_on_gpu(int gpu_index, void* buffer_input, void* buffer_output, int rows, int cols);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_transpose_on_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_transpose_on_gpu.argtypes = [c_int, c_void_p, c_void_p, c_int, c_int]
lib.execute_transpose_on_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_transpose_on_gpu(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, 0)

print(f"Call to 'execute_transpose_on_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="execute_vqe_gpu">
        <h2>execute_vqe_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>int</code></td><td><code>num_qubits</code></td></tr><tr><td><code>int</code></td><td><code>ansatz_layers</code></td></tr><tr><td><code>const float*</code></td><td><code>parameters</code></td></tr><tr><td><code>int</code></td><td><code>num_parameters</code></td></tr><tr><td><code>const PauliZTerm*</code></td><td><code>hamiltonian_terms</code></td></tr><tr><td><code>int</code></td><td><code>num_terms</code></td></tr><tr><td><code>float*</code></td><td><code>out_energy</code></td></tr><tr><td><code>float*</code></td><td><code>out_gradients</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### Funktion: execute_vqe_gpu<br />**Gruppe:** `kernel.quantum`<br /><br />#### Beschreibung<br />Führt eine VQE-Berechnung (Variational Quantum Eigensolver) auf der angegebenen GPU durch. Die Funktion berechnet den Energie-Erwartungswert eines Hamilton-Operators für einen gegebenen parametrisierten Quantenschaltkreis (Ansatz). Zusätzlich werden die Gradienten der Energie in Bezug auf die Ansatz-Parameter berechnet, was für die Optimierungsschleife des VQE-Algorithmus entscheidend ist.<br /><br />#### Anwendungshinweise<br />- Die OpenCL-Umgebung muss vor dem Aufruf dieser Funktion mit einer entsprechenden Initialisierungsfunktion (z.B. `initialize_opencl`) initialisiert werden.<br />- Der `out_energy`-Buffer muss Platz für einen einzelnen `float`-Wert haben.<br />- Der `out_gradients`-Buffer muss groß genug sein, um `num_parameters` `float`-Werte aufzunehmen.<br />- Die Anzahl der Parameter (`num_parameters`) hängt von `num_qubits` und `ansatz_layers` ab und muss vom Aufrufer korrekt berechnet werden.<br />- Die `hamiltonian_terms` sind ein Array von `PauliZTerm`-Strukturen. Diese Struktur muss in der aufrufenden Sprache (z.B. als `ctypes.Structure` in Python) definiert sein.<br />- Die Funktion gibt bei Erfolg `0` zurück, andernfalls einen Fehlercode.<br /><br />#### Python `ctypes`-Beispiel (Ausschnitt)<br />Im `ctypes`-Aufruf müssen die Platzhalter (`...`) durch die tatsächlichen Zeiger auf die Datenpuffer (`parameters`, `hamiltonian_terms`, `out_energy`, `out_gradients`) und die entsprechenden Längenvariablen ersetzt werden.<br /><br />```python<br /># Annahme: lib ist eine geladene CDLL, und alle Puffer sind korrekt initialisiert<br /># lib.execute_vqe_gpu.argtypes = [...]<br /># lib.execute_vqe_gpu.restype = ctypes.c_int<br /><br />return_code = lib.execute_vqe_gpu(<br />    gpu_index,<br />    num_qubits,<br />    ansatz_layers,<br />    parameters_ptr,       # Ersetzen: Zeiger auf den Parameter-Puffer<br />    num_parameters,       # Ersetzen: Länge des Parameter-Puffers<br />    hamiltonian_ptr,      # Ersetzen: Zeiger auf den Hamilton-Term-Puffer<br />    num_terms,            # Ersetzen: Länge des Hamilton-Puffers<br />    out_energy_ptr,       # Ersetzen: Zeiger auf den Energie-Ausgabepuffer<br />    out_gradients_ptr     # Ersetzen: Zeiger auf den Gradienten-Ausgabepuffer<br />)<br />```</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int execute_vqe_gpu(int gpu_index, int num_qubits, int ansatz_layers,
                              const float* parameters, int num_parameters,
                              const PauliZTerm* hamiltonian_terms, int num_terms,
                              float* out_energy, float* out_gradients);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for execute_vqe_gpu
from ctypes import *
from pathlib import Path

class PauliZTerm(Structure):
    _fields_ = [
        ('z_mask', c_uint64),
        ('coefficient', c_float)
    ]

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.execute_vqe_gpu.argtypes = [c_int, c_int, c_int, POINTER(c_float), c_int, c_void_p, c_int, POINTER(c_float), POINTER(c_float)]
lib.execute_vqe_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.execute_vqe_gpu(0, 0, 0, None  # TODO: provide a valid pointer/buffer, 0, None  # TODO: provide a valid pointer/buffer, 0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer)

print(f"Call to 'execute_vqe_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="finish_gpu">
        <h2>finish_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>lifecycle</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `finish_gpu`<br /><br />#### Kurzbeschreibung<br /><br />Gibt alle OpenCL-Ressourcen frei, die einem bestimmten GPU-Index zugeordnet sind. Dies umfasst den OpenCL-Kontext, die Befehlswarteschlange (Command Queue) und alle verbleibenden Speicherpuffer. Rufen Sie diese Funktion am Ende Ihres Programms oder nach Abschluss aller GPU-Berechnungen auf, um Ressourcen ordnungsgemäß freizugeben.<br /><br />#### Anwendungshinweise<br /><br />-   Die GPU mit dem angegebenen `gpu_index` muss zuvor erfolgreich mit `init_gpu` initialisiert worden sein.<br />-   Dies ist eine Bereinigungsfunktion und die logische Gegenoperation zu `init_gpu`.<br />-   Nach dem Aufruf können keine weiteren GPU-Operationen für diesen Index ausgeführt werden, ohne `init_gpu` erneut aufzurufen.<br />-   Gibt `0` bei erfolgreicher Freigabe der Ressourcen zurück.<br />-   Gibt einen negativen Wert zurück, wenn der `gpu_index` ungültig ist oder die GPU nicht initialisiert war.<br /><br />#### Hinweis zur ctypes-Nutzung<br /><br />Für den Aufruf mit ctypes übergeben Sie den `gpu_index` als einfachen Python-Integer. Es sind keine Pointer oder Längenangaben erforderlich.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int finish_gpu(int gpu_index);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for finish_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.finish_gpu.argtypes = [c_int]
lib.finish_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.finish_gpu(0)

print(f"Call to 'finish_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="free_gpu_memory">
        <h2>free_gpu_memory()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>memory</code></span>
          <span><strong>Returns:</strong> <code>void</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>buffer_handle</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `free_gpu_memory`<br /><br />#### Kurzbeschreibung<br />Gibt auf einer bestimmten GPU zugewiesenen Speicher frei. Rufen Sie diese Funktion auf, wenn ein mit `allocate_gpu_memory` erstellter Puffer nicht mehr benötigt wird, um Speicherlecks zu verhindern. Jeder Speicherzuweisung sollte eine entsprechende Freigabe folgen.<br /><br />#### Anwendungshinweise<br />- Der `gpu_index` muss mit dem Index übereinstimmen, der bei der ursprünglichen Speicherzuweisung verwendet wurde.<br />- Der Parameter `buffer_handle` muss ein gültiger Pointer sein, der zuvor von einer Zuweisungsfunktion zurückgegeben wurde.<br />- Nach dem Aufruf dieser Funktion ist der `buffer_handle` ungültig und darf nicht mehr verwendet werden.<br />- Die Angabe eines ungültigen Handles oder Index kann zu undefiniertem Verhalten oder Programmabstürzen führen.<br /><br />#### Python ctypes Snippet<br />Im Python-Beispiel müssen der `gpu_index` und der `buffer_handle`, der von der Zuweisungsfunktion erhalten wurde, als Argumente übergeben werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT void free_gpu_memory(int gpu_index, void* buffer_handle);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for free_gpu_memory
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.free_gpu_memory.argtypes = [c_int, c_void_p]
lib.free_gpu_memory.restype = c_void_p

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.free_gpu_memory(0, None  # TODO: provide a valid pointer/buffer)

print(f"Call to 'free_gpu_memory' returned: {result}")</code></pre>
      </section>
    
      <section id="get_last_kernel_metrics">
        <h2>get_last_kernel_metrics()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>metrics</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>KernelMetricsSample*</code></td><td><code>out_metrics</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### get_last_kernel_metrics<br /><br />#### Beschreibung<br />Ruft die Leistungsmetriken des zuletzt auf einer bestimmten GPU ausgeführten Kernels ab. Diese Funktion ist für das Profiling und die Leistungsanalyse vorgesehen und sollte unmittelbar nach einem Kernel-Aufruf (z. B. `run_sgemm_kernel`) verwendet werden, um dessen Ausführungszeit zu erfassen. Die Metriken werden in die vom Aufrufer bereitgestellte `KernelMetricsSample`-Struktur geschrieben.<br /><br />#### Anwendungshinweise<br />*   Die GPU muss zuvor mit `initialize_opencl` initialisiert worden sein.<br />*   Es muss mindestens ein Kernel auf der durch `gpu_index` spezifizierten GPU ausgeführt worden sein, damit gültige Metriken verfügbar sind.<br />*   Der `gpu_index` muss ein gültiger Index sein, der bei der Initialisierung ermittelt wurde.<br />*   Der Parameter `out_metrics` muss ein gültiger Zeiger auf eine bereits allozierte `KernelMetricsSample`-Struktur sein, in die die Ergebnisse geschrieben werden.<br />*   Die Funktion gibt `SUCCESS` (0) bei Erfolg oder einen Fehlercode bei Misserfolg zurück (z.B. wenn der Index ungültig ist oder noch keine Metriken verfügbar sind).<br /><br />#### Python ctypes Beispiel<br />Um diese Funktion mit `ctypes` in Python zu nutzen, erstellen Sie eine Instanz der `KernelMetricsSample`-Struktur. Übergeben Sie diese Instanz dann mittels `ctypes.byref()` an die Funktion, um sie als Zeiger (`KernelMetricsSample*`) zu behandeln. Stellen Sie sicher, dass die Python-Definition der Struktur exakt der C-Definition entspricht.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int get_last_kernel_metrics(int gpu_index, KernelMetricsSample* out_metrics);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for get_last_kernel_metrics
from ctypes import *
from pathlib import Path

class KernelMetricsSample(Structure):
    _fields_ = [
        ('name[64]', c_char),
        ('duration_ms', c_float),
        ('error', c_float),
        ('variance', c_float)
    ]

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.get_last_kernel_metrics.argtypes = [c_int, c_void_p]
lib.get_last_kernel_metrics.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.get_last_kernel_metrics(0, None  # TODO: provide a valid pointer/buffer)

print(f"Call to 'get_last_kernel_metrics' returned: {result}")</code></pre>
      </section>
    
      <section id="get_noise_level">
        <h2>get_noise_level()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>noisectrl</code></span>
          <span><strong>Returns:</strong> <code>float</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `get_noise_level`<br /><br />#### Beschreibung<br /><br />Ruft das aktuell konfigurierte Rauschniveau für ein bestimmtes GPU-Gerät ab. Diese Funktion ist nützlich, um den Zustand von Rausch-basierten Regularisierungs- oder Datenaugmentierungsmechanismen während des Trainings zu überprüfen. Das Rauschniveau wird typischerweise von einer entsprechenden `set_noise_level`-Funktion festgelegt.<br /><br />#### Anwendungshinweise<br /><br />*   Die GPU-Umgebung muss vor dem Aufruf dieser Funktion mit `init_opencl` initialisiert worden sein.<br />*   Der `gpu_index` muss einem gültigen, initialisierten Gerät entsprechen und im Bereich von 0 bis `get_gpu_count() - 1` liegen.<br />*   Die Funktion gibt das Rauschniveau als Gleitkommazahl zurück. Ein Wert von 0.0 bedeutet typischerweise, dass kein Rauschen angewendet wird.<br />*   Im Fehlerfall (z. B. bei einem ungültigen `gpu_index`) wird ein negativer Wert wie `-1.0f` zurückgegeben.<br />*   Der zurückgegebene Wert spiegelt den zuletzt über eine `set_`-Funktion gesetzten Zustand oder den Standardwert nach der Initialisierung wider.<br /><br />#### ctypes-Beispiel<br /><br />Binden Sie die Funktion mit `ctypes` in Python ein. Stellen Sie sicher, dass `argtypes` auf `[ctypes.c_int]` und `restype` auf `ctypes.c_float` gesetzt ist, um eine korrekte Typumwandlung zu gewährleisten.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT float get_noise_level(int gpu_index);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for get_noise_level
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.get_noise_level.argtypes = [c_int]
lib.get_noise_level.restype = c_float

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.get_noise_level(0)

print(f"Call to 'get_noise_level' returned: {result}")</code></pre>
      </section>
    
      <section id="initialize_gpu">
        <h2>initialize_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>init</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `initialize_gpu`<br /><br />#### Beschreibung<br />Initialisiert ein bestimmtes GPU-Gerät für nachfolgende OpenCL-Operationen. Diese Funktion richtet den OpenCL-Kontext und die Befehlswarteschlange (Command Queue) für das ausgewählte Gerät ein. Sie muss als erste GPU-bezogene Funktion aufgerufen werden, bevor andere Berechnungs- oder Datenübertragungsfunktionen verwendet werden können.<br /><br />#### Anwendungshinweise<br />- Muss vor allen anderen GPU-Funktionen der Bibliothek aufgerufen werden.<br />- `gpu_index` ist der nullbasierte Index des zu verwendenden Geräts. Index `0` wählt typischerweise das Standard- oder erste verfügbare GPU-Gerät aus.<br />- Rufen Sie diese Funktion nur einmal zu Beginn der Anwendung auf, es sei denn, die GPU-Ressourcen werden explizit freigegeben.<br />- Gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehler, z. B. `-1`, wenn der Index ungültig ist oder keine kompatible OpenCL-Plattform gefunden wurde.<br /><br />#### ctypes-Integration<br />Im `ctypes`-Code-Snippet müssen keine Pointer oder Längen angepasst werden. Der `gpu_index` wird direkt als Python `int` übergeben.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int initialize_gpu(int gpu_index);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for initialize_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.initialize_gpu.argtypes = [c_int]
lib.initialize_gpu.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.initialize_gpu(0)

print(f"Call to 'initialize_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="quantum_apply_gate_sequence">
        <h2>quantum_apply_gate_sequence()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>int</code></td><td><code>num_qubits</code></td></tr><tr><td><code>float*</code></td><td><code>out_probabilities</code></td></tr><tr><td><code>int</code></td><td><code>probability_length</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `quantum_apply_gate_sequence`<br /><br />#### Beschreibung<br />Führt eine zuvor definierte Sequenz von Quantengattern auf einem simulierten Quantenzustand aus. Die Funktion initialisiert den Zustand auf |0...0>, wendet die Gatter an und berechnet die finalen Messwahrscheinlichkeiten für jeden Basiszustand. Dies ist der zentrale Schritt zur Ausführung eines Quantenschaltkreises auf der GPU.<br /><br />#### Anwendungshinweise<br />*   Die GPU, identifiziert durch `gpu_index`, muss zuvor initialisiert worden sein.<br />*   Eine Gattersquenz muss vor dem Aufruf dieser Funktion mit einer entsprechenden Funktion (z.B. `quantum_set_gate_sequence`) auf die GPU geladen werden.<br />*   Der `out_probabilities`-Puffer muss eine Länge von `2^num_qubits` haben, um die Wahrscheinlichkeit für jeden möglichen Basiszustand zu speichern.<br />*   Der Parameter `probability_length` muss exakt der Größe des Puffers entsprechen, also `2^num_qubits`.<br />*   Die Funktion gibt `0` bei Erfolg und einen negativen Fehlercode bei Misserfolg zurück (z.B. wenn kein Gatter-Programm geladen wurde oder die Puffergröße nicht ausreicht).<br /><br />#### Python (ctypes) Anbindung<br />Passen Sie im ctypes-Aufruf den Pointer für `out_probabilities` und den Wert für `probability_length` entsprechend dem von Ihnen erstellten Puffer an.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int quantum_apply_gate_sequence(int gpu_index, int num_qubits, float* out_probabilities, int probability_length);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for quantum_apply_gate_sequence
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.quantum_apply_gate_sequence.argtypes = [c_int, c_int, POINTER(c_float), c_int]
lib.quantum_apply_gate_sequence.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.quantum_apply_gate_sequence(0, 0, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'quantum_apply_gate_sequence' returned: {result}")</code></pre>
      </section>
    
      <section id="quantum_export_to_qasm">
        <h2>quantum_export_to_qasm()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>const char*</code></td><td><code>filepath</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `quantum_export_to_qasm`<br /><br />#### Beschreibung<br />Exportiert den aktuellen Zustand eines Quantenschaltkreises von der angegebenen GPU in eine Datei im QASM-Format (Quantum Assembly Language). Diese Funktion ist nützlich, um den simulierten Zustand für die spätere Analyse, das Debugging oder die Übertragung auf andere Quantencomputer-Plattformen zu speichern. Der Export ist eine blockierende Operation, die den Zustand aus dem GPU-Speicher liest und in die Zieldatei schreibt.<br /><br />#### Hinweise zur Verwendung<br />*   Die GPU mit dem angegebenen `gpu_index` muss zuvor initialisiert worden sein und einen aktiven Quantensimulationskontext enthalten.<br />*   Der `filepath` muss auf einen gültigen, schreibbaren Speicherort zeigen. Übergeordnete Verzeichnisse müssen bereits existieren.<br />*   Die Funktion gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehler, z. B. einen ungültigen `gpu_index`, einen Fehler beim Dateizugriff oder einen Fehler beim Lesen des GPU-Speichers.<br />*   Eine bereits existierende Datei am Zielpfad wird ohne Rückfrage überschrieben.<br />*   Bei der Verwendung mit Python (`ctypes`) muss der Dateipfad als Byte-String (z. B. `b'path/to/file.qasm'`) übergeben werden.<br /><br />#### Ctypes Snippet-Anleitung<br />Im `ctypes`-Code-Snippet muss der `gpu_index` durch den Index der Ziel-GPU ersetzt werden. Der Platzhalter für den Dateipfad sollte durch einen zu `utf-8` kodierten Byte-String (z. B. `b"C:/temp/circuit_state.qasm"`) ersetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int quantum_export_to_qasm(int gpu_index, const char* filepath);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for quantum_export_to_qasm
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.quantum_export_to_qasm.argtypes = [c_int, POINTER(c_char)]
lib.quantum_export_to_qasm.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.quantum_export_to_qasm(0, None  # TODO: provide a valid pointer/buffer)

print(f"Call to 'quantum_export_to_qasm' returned: {result}")</code></pre>
      </section>
    
      <section id="quantum_upload_gate_sequence">
        <h2>quantum_upload_gate_sequence()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>const QuantumGate*</code></td><td><code>gates</code></td></tr><tr><td><code>int</code></td><td><code>gate_count</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `quantum_upload_gate_sequence`<br /><br />#### Beschreibung<br />Überträgt eine Sequenz von Quantengattern vom Host-Speicher (CPU) in einen dedizierten Puffer auf der angegebenen GPU. Diese Funktion ist ein notwendiger Vorbereitungsschritt vor der Ausführung eines Quanten-Kernels, der diese Gattersequenz verarbeitet. Sie stellt sicher, dass die Gatterdaten für die GPU-Berechnung verfügbar sind.<br /><br />#### Anwendungshinweise<br />*   Die Ziel-GPU muss zuvor mit dem korrekten `gpu_index` initialisiert worden sein.<br />*   Der `gates`-Zeiger muss auf ein valides Array von `QuantumGate`-Strukturen im Host-Speicher verweisen.<br />*   Die Größe des zu übertragenden Puffers wird durch `gate_count` bestimmt. Stellen Sie sicher, dass der `gates`-Array mindestens `gate_count` Elemente enthält.<br />*   Ein erneuter Aufruf für denselben `gpu_index` überschreibt die zuvor hochgeladene Gattersequenz.<br />*   Gibt `0` bei Erfolg zurück. Ein negativer Wert signalisiert einen Fehler, z. B. einen ungültigen `gpu_index` oder einen OpenCL-Fehler bei der Puffererstellung oder -übertragung.<br /><br />#### Python ctypes Snippet<br />Im Python-Wrapper muss der `gates`-Parameter als Zeiger auf ein Array von `QuantumGate`-Strukturen (`ctypes.POINTER(...)`) übergeben werden. Der `gate_count`-Parameter muss der Länge dieses Arrays entsprechen.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int quantum_upload_gate_sequence(int gpu_index, const QuantumGate* gates, int gate_count);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for quantum_upload_gate_sequence
from ctypes import *
from pathlib import Path

class QuantumGate(Structure):
    _fields_ = [
        ('name[8]', c_char),
        ('arity', c_void_p),
        ('control', c_void_p),
        ('target', c_void_p),
        ('control2', c_void_p),
        ('params[4]', c_float),
        ('matrix[8][8]', c_void_p)
    ]

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.quantum_upload_gate_sequence.argtypes = [c_int, c_void_p, c_int]
lib.quantum_upload_gate_sequence.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.quantum_upload_gate_sequence(0, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'quantum_upload_gate_sequence' returned: {result}")</code></pre>
      </section>
    
      <section id="read_gpu_to_host_blocking">
        <h2>read_gpu_to_host_blocking()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>transfer</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>gpu_buffer_handle</code></td></tr><tr><td><code>size_t</code></td><td><code>offset</code></td></tr><tr><td><code>size_t</code></td><td><code>size</code></td></tr><tr><td><code>void*</code></td><td><code>host_destination_ptr</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `read_gpu_to_host_blocking`<br /><br />#### Kurzbeschreibung<br />Kopiert Daten blockierend von einem GPU-Puffer in den Host-Speicher (RAM). Die Funktion kehrt erst zurück, wenn die Übertragung vollständig abgeschlossen ist, was die Programmausführung solange anhält. Dies ist nützlich, um Berechnungsergebnisse von der GPU abzurufen, bevor sie auf der CPU weiterverarbeitet oder angezeigt werden.<br /><br />#### Verwendungshinweise<br />- **Voraussetzungen:** `gpu_buffer_handle` muss ein gültiger, zuvor allozierter Puffer-Handle sein. `host_destination_ptr` muss auf einen bereits im Host-Speicher alloziierten Puffer zeigen.<br />- **Puffergrößen:** Der Zielpuffer im Host muss mindestens `size` Bytes groß sein. Die Summe aus `offset` und `size` darf die Gesamtgröße des GPU-Puffers nicht überschreiten.<br />- **Synchrones Verhalten:** Dies ist ein synchroner (blockierender) Aufruf. Der aufrufende Thread wird angehalten, bis der Kopiervorgang beendet ist.<br />- **Geräteindex:** Der `gpu_index` muss mit dem Gerät übereinstimmen, auf dem der Puffer ursprünglich erstellt wurde.<br />- **Fehlercodes:** Ein Rückgabewert ungleich `0` signalisiert einen Fehler, z.B. einen ungültigen Handle oder einen Speicherzugriff außerhalb der Grenzen.<br /><br />#### Hinweis zum ctypes-Snippet<br />Ersetzen Sie im Codebeispiel die Zeiger für den `gpu_buffer_handle` und den `host_destination_ptr` sowie die Werte für `offset` und `size` mit Ihren konkreten Daten.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int read_gpu_to_host_blocking(int gpu_index, void* gpu_buffer_handle, size_t offset, size_t size, void* host_destination_ptr);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for read_gpu_to_host_blocking
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.read_gpu_to_host_blocking.argtypes = [c_int, c_void_p, c_size_t, c_size_t, c_void_p]
lib.read_gpu_to_host_blocking.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.read_gpu_to_host_blocking(0, None  # TODO: provide a valid pointer/buffer, 0, 0, None  # TODO: provide a valid pointer/buffer)

print(f"Call to 'read_gpu_to_host_blocking' returned: {result}")</code></pre>
      </section>
    
      <section id="register_kernel_measurement_buffers">
        <h2>register_kernel_measurement_buffers()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>metrics</code></span>
          <span><strong>Returns:</strong> <code>void</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>float*</code></td><td><code>error_ptr</code></td></tr><tr><td><code>float*</code></td><td><code>variance_ptr</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `register_kernel_measurement_buffers`<br /><br />#### Kurzbeschreibung<br /><br />Registriert zwei vom Aufrufer bereitgestellte Speicherpuffer beim OpenCL-Treiber, um Metriken zu erfassen. Die Puffer werden verwendet, um aggregierte Werte für Fehler (error) und Varianz (variance) direkt von den GPU-Kerneln zu empfangen. Diese Funktion ist notwendig, um Leistungs- oder Genauigkeitsmetriken während der Kernel-Ausführung zu überwachen.<br /><br />#### Anwendungshinweise<br /><br />- **Voraussetzung:** Die OpenCL-Umgebung muss vor dem Aufruf dieser Funktion mit `initialize_opencl` initialisiert worden sein.<br />- **Puffergröße:** Jeder Zeiger (`error_ptr`, `variance_ptr`) muss auf einen Speicherbereich zeigen, der mindestens die Größe eines einzelnen `float`-Wertes (`sizeof(float)`) hat.<br />- **Datenfluss:** Der Aufrufer (C- oder Python-Code) allokiert den Speicher. Der OpenCL-Treiber schreibt die berechneten Metrik-Werte nach der Ausführung relevanter Kernel in diesen Speicher.<br />- **Lebenszyklus:** Der Speicher für die Puffer muss für die gesamte Dauer, in der die Metriken erfasst werden sollen, gültig bleiben.<br />- **Fehlerbehandlung:** Die Funktion selbst gibt keinen Statuscode zurück. Nach der Kernel-Ausführung sollten die Werte in den Puffern auf Gültigkeit (z.B. nicht NaN) geprüft werden.<br /><br />#### Ctypes Python-Beispiel<br /><br />Im Python-CTypes-Snippet müssen Sie zwei `c_float`-Variablen erstellen. Übergeben Sie diese Variablen mithilfe von `byref()` an die Funktion, um Zeiger auf ihren Speicherort zu erzeugen.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT void register_kernel_measurement_buffers(float* error_ptr, float* variance_ptr);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for register_kernel_measurement_buffers
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.register_kernel_measurement_buffers.argtypes = [POINTER(c_float), POINTER(c_float)]
lib.register_kernel_measurement_buffers.restype = c_void_p

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.register_kernel_measurement_buffers(None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer)

print(f"Call to 'register_kernel_measurement_buffers' returned: {result}")</code></pre>
      </section>
    
      <section id="reset_kernel_measurement_buffers">
        <h2>reset_kernel_measurement_buffers()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>metrics</code></span>
          <span><strong>Returns:</strong> <code>void</code></span>
        </div>
        <h3>Parameters</h3>
        <p><em>No parameters</em></p>
        <h3>Description</h3>
        <div class="prose">### `reset_kernel_measurement_buffers`<br /><br />#### Kurzbeschreibung<br /><br />Setzt die internen Puffer für die Leistungsmessung von Kernel-Ausführungen zurück. Diese Funktion sollte vor dem Start einer neuen Benchmark-Sequenz aufgerufen werden, um sicherzustellen, dass die gesammelten Metriken (z. B. durchschnittliche Ausführungszeiten) nicht durch vorherige Läufe verfälscht werden. Alle vorherigen Messdaten gehen dabei verloren.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzung:** Die OpenCL-Umgebung muss erfolgreich mit `initialize_opencl` initialisiert worden sein.<br />*   **Funktionsweise:** Intern werden alle Zähler und Zeit-Akkumulatoren für die Kernel-Performance-Messung auf null gesetzt.<br />*   **Lebenszyklus:** Rufen Sie diese Funktion einmal auf, bevor Sie eine Schleife oder einen Codeblock ausführen, in dem die Leistung von Kerneln gemessen und aggregiert werden soll.<br />*   **Fehlercodes:** Die Funktion gibt keinen Wert zurück und meldet keine Fehler.<br /><br />#### Python `ctypes` Anwendungsbeispiel<br /><br />Da die Funktion keine Parameter entgegennimmt und keinen Wert zurückgibt, ist der Aufruf über Python `ctypes` unkompliziert. Es müssen keine Pointer oder Längenangaben im Snippet angepasst werden.<br /><br />```python<br />import ctypes<br /><br /># Lade die DLL<br />lib = ctypes.CDLL("CipherCore_OpenCl.dll")<br /><br /># Definiere den Prototyp der Funktion<br />lib.reset_kernel_measurement_buffers.argtypes = []<br />lib.reset_kernel_measurement_buffers.restype = None<br /><br /># Rufe die Funktion auf, um die Messungen zurückzusetzen<br />print("Resetting kernel measurement buffers...")<br />lib.reset_kernel_measurement_buffers()<br />print("Done.")<br /><br /># ... hier folgen Kernel-Aufrufe, deren Leistung gemessen werden soll ...<br />```</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT void reset_kernel_measurement_buffers(void);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for reset_kernel_measurement_buffers
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.reset_kernel_measurement_buffers.argtypes = []
lib.reset_kernel_measurement_buffers.restype = c_void_p

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.reset_kernel_measurement_buffers()

print(f"Call to 'reset_kernel_measurement_buffers' returned: {result}")</code></pre>
      </section>
    
      <section id="set_noise_level">
        <h2>set_noise_level()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>noisectrl</code></span>
          <span><strong>Returns:</strong> <code>void</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>float</code></td><td><code>value</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">Absolut. Hier ist die Dokumentation für `set_noise_level`.<br /><br />---<br /><br />### `set_noise_level`<br /><br />Setzt die Intensität des stochastischen Rauschens für eine bestimmte GPU. Diese Funktion wird typischerweise während des Trainings von Modellen verwendet, um eine Form der Regularisierung zu implementieren. Das Hinzufügen von Rauschen kann die Generalisierungsfähigkeit des Modells verbessern, indem ein Overfitting auf die Trainingsdaten verhindert wird.<br /><br />**Anwendungshinweise:**<br /><br />*   Die GPU muss vor dem Aufruf dieser Funktion mit `init_opencl` initialisiert worden sein.<br />*   Der Parameter `gpu_index` muss ein gültiger Index eines initialisierten Geräts sein (z. B. 0 für die erste GPU).<br />*   Der `value` ist ein nicht-negativer Fließkommawert, der die Stärke des Rauschens angibt. Ein Wert von `0.0` deaktiviert das Rauschen effektiv.<br />*   Die Einstellung gilt global für die angegebene GPU und beeinflusst alle nachfolgenden Kernel-Ausführungen, die diese Rauschkomponente nutzen.<br /><br />**C-Prototyp:**<br />```c<br />DLLEXPORT void set_noise_level(int gpu_index, float value);<br />```<br /><br />**Python-Beispiel (ctypes):**<br />```python<br />import ctypes<br /><br /># Pfad zur DLL/SO-Datei<br />lib_path = "CipherCore_OpenCl.dll"<br />lib = ctypes.CDLL(lib_path)<br /><br /># Funktionsprototyp definieren<br />lib.set_noise_level.argtypes = [ctypes.c_int, ctypes.c_float]<br />lib.set_noise_level.restype = None<br /><br /># Funktion aufrufen<br />gpu_id = 0<br />noise_value = 0.05<br />lib.set_noise_level(gpu_id, ctypes.c_float(noise_value))<br />```<br />Passen Sie den Pfad zur DLL sowie die Werte für `gpu_index` und `value` entsprechend an.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT void set_noise_level(int gpu_index, float value);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for set_noise_level
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.set_noise_level.argtypes = [c_int, c_float]
lib.set_noise_level.restype = c_void_p

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.set_noise_level(0, 0.0)

print(f"Call to 'set_noise_level' returned: {result}")</code></pre>
      </section>
    
      <section id="shutdown_gpu">
        <h2>shutdown_gpu()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>lifecycle</code></span>
          <span><strong>Returns:</strong> <code>void</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### Kurzbeschreibung<br /><br />Fährt eine zuvor initialisierte GPU herunter und gibt alle zugehörigen OpenCL-Ressourcen frei. Zu diesen Ressourcen gehören der Kontext, die Befehlswarteschlange (Command Queue) und alle auf dem Gerät zugewiesenen Puffer. Rufen Sie diese Funktion auf, wenn eine GPU nicht mehr benötigt wird, um Speicherlecks zu vermeiden.<br /><br />### Anwendungshinweise<br /><br />- Die GPU mit dem angegebenen `gpu_index` muss zuvor erfolgreich mit einer Initialisierungsfunktion (z. B. `init_gpu`) initialisiert worden sein.<br />- Der `gpu_index` muss ein gültiger Index sein, der bei der Initialisierung oder GPU-Enumeration ermittelt wurde.<br />- Nach dem Aufruf dieser Funktion sind alle Handles und Puffer, die mit dieser GPU verknüpft sind, ungültig und dürfen nicht mehr verwendet werden.<br />- Ein mehrfacher Aufruf für denselben `gpu_index` kann zu undefiniertem Verhalten oder einem Absturz führen.<br />- Die Funktion gibt keinen Status- oder Fehlercode zurück.<br /><br />### Ctypes-Beispiel-Hinweis<br /><br />Im Ctypes-Snippet muss die `argtypes`-Liste der Funktion so konfiguriert werden, dass sie einen einzelnen `c_int` für den `gpu_index` akzeptiert. Da die Funktion `void` zurückgibt, sollte `restype` auf `None` gesetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT void shutdown_gpu(int gpu_index);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for shutdown_gpu
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.shutdown_gpu.argtypes = [c_int]
lib.shutdown_gpu.restype = c_void_p

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.shutdown_gpu(0)

print(f"Call to 'shutdown_gpu' returned: {result}")</code></pre>
      </section>
    
      <section id="simulated_kernel_free">
        <h2>simulated_kernel_free()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>misc</code></span>
          <span><strong>Returns:</strong> <code>void</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>unsigned long long</code></td><td><code>address</code></td></tr><tr><td><code>size_t size) { if (address == 0) return;</code></td><td><code>free((void*)(uintptr_t)address</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `simulated_kernel_free`<br /><br />#### Kurzbeschreibung<br /><br />Gibt einen Speicherblock im Host-RAM (CPU) frei, der zuvor mit `simulated_kernel_malloc` alloziert wurde. Diese Funktion ist für Test- oder Simulationszwecke gedacht, bei denen keine echte GPU-Speicherverwaltung stattfindet. Sie ist das Gegenstück zur C-Standardbibliotheksfunktion `free()` und gibt **keinen** GPU-Speicher frei.<br /><br />#### Anwendungshinweise<br /><br />*   Darf ausschließlich auf Adressen angewendet werden, die von `simulated_kernel_malloc` zurückgegeben wurden.<br />*   Das mehrfache Freigeben derselben Adresse führt zu undefiniertem Verhalten (typischerweise einem Absturz).<br />*   Die Parameter `gpu_index` und `size` werden für die API-Kompatibilität beibehalten, aber von dieser Funktion ignoriert.<br />*   Dies ist eine Host-Speicheroperation und interagiert nicht mit dem OpenCL-Gerät oder dessen Treibern.<br />*   Nach dem Aufruf ist der Zeiger (die `address`) ungültig und darf nicht mehr verwendet werden.<br /><br />#### Python `ctypes` Beispiel<br /><br />Im Python `ctypes`-Wrapper definieren Sie die Funktionssignatur. Beim Aufruf übergeben Sie den ganzzahligen `address`-Wert, den Sie von `simulated_kernel_malloc` erhalten haben.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT void simulated_kernel_free(int gpu_index, unsigned long long address, size_t size) {
    if (address == 0) return;
    free((void*)(uintptr_t)address);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for simulated_kernel_free
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.simulated_kernel_free.argtypes = [c_int, c_uint64, c_void_p]
lib.simulated_kernel_free.restype = c_void_p

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.simulated_kernel_free(0, None  # TODO: handle custom type/struct, None  # TODO: handle custom type/struct)

print(f"Call to 'simulated_kernel_free' returned: {result}")</code></pre>
      </section>
    
      <section id="simulated_kernel_write">
        <h2>simulated_kernel_write()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>misc</code></span>
          <span><strong>Returns:</strong> <code>void</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>unsigned long long</code></td><td><code>address</code></td></tr><tr><td><code>size_t</code></td><td><code>size</code></td></tr><tr><td><code>const void *source) { if (address == 0 || size == 0 || source == NULL) return; memcpy((void*)(uintptr_t)address, source,</code></td><td><code>size</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">Absolut. Hier ist die Dokumentation für `simulated_kernel_write`, verfasst für C/Python-Entwickler.<br /><br />---<br /><br />### `simulated_kernel_write`<br /><br />#### Kurzbeschreibung<br /><br />Simuliert das Schreiben von Daten in einen GPU-Puffer, indem eine CPU-basierte Speicheroperation (`memcpy`) ausgeführt wird. Diese Funktion interagiert nicht mit einer realen GPU und dient ausschließlich Test- und Debugging-Zwecken oder als Fallback in Umgebungen ohne OpenCL-Gerät. Sie kopiert einen Datenblock aus einem Quellpuffer im Host-Speicher an eine angegebene Zieladresse.<br /><br />#### Anwendungshinweise<br /><br />*   **Zweck:** Dies ist eine reine Debugging- und Fallback-Funktion. Sie führt keine Operationen auf einer GPU aus.<br />*   **Parameter `gpu_index`:** Dieser Parameter wird in der Implementierung ignoriert.<br />*   **Adresse (`address`):** Muss ein gültiger, beschreibbarer Speicherzeiger im Host-Speicher sein, typischerweise von einer simulierten Allokationsfunktion zurückgegeben. Ein Wert von `0` wird ignoriert.<br />*   **Quelle (`source`):** Muss ein gültiger Zeiger auf den Quellpuffer im Host-Speicher sein. Ein `NULL`-Zeiger wird ignoriert.<br />*   **Größe (`size`):** Die Größe der zu kopierenden Daten in Bytes. Sie darf nicht größer sein als die Puffergrößen von Quelle und Ziel, um Speicherüberläufe zu vermeiden. Ein Wert von `0` wird ignoriert.<br />*   **Sicherheit:** Die Funktion prüft nicht die Gültigkeit der übergebenen Adressen oder Größen. Der Aufrufer ist für die Bereitstellung korrekter Werte verantwortlich, um Abstürze oder Speicherfehler zu verhindern.<br /><br />#### Python (ctypes) Beispiel<br /><br />```python<br />import ctypes<br />import numpy as np<br /><br /># Laden der DLL<br />lib = ctypes.CDLL("CipherCore_OpenCl.dll")<br /><br /># Definieren des Funktionsprototyps<br />lib.simulated_kernel_write.argtypes = [<br />    ctypes.c_int,<br />    ctypes.c_uint64,<br />    ctypes.c_size_t,<br />    ctypes.c_void_p<br />]<br />lib.simulated_kernel_write.restype = None<br /><br /># --- Ersetzen Sie die folgenden Platzhalter ---<br /><br /># Annahme: Sie haben eine Adresse von einer simulierten Allokation erhalten<br /># Für dieses Beispiel simulieren wir auch den Zielpuffer<br />target_buffer = (ctypes.c_float * 10)()<br />target_address = ctypes.addressof(target_buffer)<br /><br /># Quelldaten (z.B. ein NumPy-Array)<br />source_data = np.arange(10, dtype=np.float32)<br />source_pointer = source_data.ctypes.data_as(ctypes.c_void_p)<br />data_size = source_data.nbytes<br /><br /># Funktionsaufruf<br />lib.simulated_kernel_write(0, target_address, data_size, source_pointer)<br /><br /># Überprüfung (optional)<br /># print(list(target_buffer))<br />```<br /><br />Ersetzen Sie im Code-Snippet `target_address` durch die von einer (simulierten) Speicherallokationsfunktion erhaltene Adresse. Passen Sie `source_data` und die entsprechenden Zeiger (`source_pointer`) und Größen (`data_size`) an Ihre Anwendungsdaten an.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT void simulated_kernel_write(int gpu_index, unsigned long long address, size_t size, const void *source) {
    if (address == 0 || size == 0 || source == NULL) return;
    memcpy((void*)(uintptr_t)address, source, size);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for simulated_kernel_write
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.simulated_kernel_write.argtypes = [c_int, c_uint64, c_size_t, c_void_p]
lib.simulated_kernel_write.restype = c_void_p

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.simulated_kernel_write(0, None  # TODO: handle custom type/struct, 0, None  # TODO: provide a valid pointer/buffer)

print(f"Call to 'simulated_kernel_write' returned: {result}")</code></pre>
      </section>
    
      <section id="subqg_initialize_state">
        <h2>subqg_initialize_state()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>float</code></td><td><code>initial_energy</code></td></tr><tr><td><code>float</code></td><td><code>initial_phase</code></td></tr><tr><td><code>float</code></td><td><code>noise_level</code></td></tr><tr><td><code>float</code></td><td><code>threshold</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">Absolut. Hier ist die Dokumentation für `subqg_initialize_state` im geforderten Format.<br /><br />---<br /><br />### `subqg_initialize_state`<br /><br />#### Kurzbeschreibung<br /><br />Initialisiert den Zustand des Sub-Quantengitter-Simulationskernels auf einer bestimmten GPU. Diese Funktion konfiguriert die Anfangsparameter wie Energie, Phase, Rauschen und Schwellenwert. Sie muss vor der Ausführung von Quanten-Kernel-Operationen aufgerufen werden, um den Ausgangszustand des Systems festzulegen.<br /><br />#### Anwendungshinweise<br /><br />*   Die OpenCL-Umgebung muss zuvor mit einer globalen Initialisierungsfunktion (z. B. `cc_initialize`) für den Ziel-GPU initialisiert worden sein.<br />*   Der `gpu_index` muss einem gültigen, initialisierten Gerät entsprechen.<br />*   Die Funktion allokiert intern die notwendigen GPU-Puffer für den Zustandsvektor und initialisiert sie mit den übergebenen Werten.<br />*   Ein wiederholter Aufruf für denselben `gpu_index` setzt den Zustand zurück und reinitialisiert ihn mit den neuen Parametern.<br />*   Ein Rückgabewert von `0` signalisiert Erfolg. Ein negativer Wert deutet auf einen Fehler hin (z. B. ungültiger `gpu_index` oder Allokierungsfehler).<br /><br />#### Ctypes-Anbindung (Python)<br /><br />Da diese Funktion nur skalare Typen (`int`, `float`) als Parameter verwendet, sind keine speziellen Anpassungen für Zeiger oder Puffergrößen im `ctypes`-Aufruf notwendig. Die Argumente können direkt als Python `int` und `float` übergeben werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int subqg_initialize_state(int gpu_index, float initial_energy, float initial_phase, float noise_level, float threshold);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for subqg_initialize_state
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.subqg_initialize_state.argtypes = [c_int, c_float, c_float, c_float, c_float]
lib.subqg_initialize_state.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.subqg_initialize_state(0, 0.0, 0.0, 0.0, 0.0)

print(f"Call to 'subqg_initialize_state' returned: {result}")</code></pre>
      </section>
    
      <section id="subqg_initialize_state_batched">
        <h2>subqg_initialize_state_batched()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>int</code></td><td><code>cell_count</code></td></tr><tr><td><code>const float*</code></td><td><code>initial_energy</code></td></tr><tr><td><code>const float*</code></td><td><code>initial_phase</code></td></tr><tr><td><code>float</code></td><td><code>noise_level</code></td></tr><tr><td><code>float</code></td><td><code>threshold</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `subqg_initialize_state_batched`<br /><br />#### Kurzbeschreibung<br /><br />Diese Funktion initialisiert einen Batch von Sub-Quanten-Gatter (SQG) Zuständen auf einem bestimmten GPU-Gerät. Sie legt die anfängliche Energie und Phase für jede Zelle fest, wobei ein globales Rauschniveau und ein Schwellenwert angewendet werden. Diese Funktion wird zu Beginn einer Simulation aufgerufen, um die Anfangsbedingungen zu definieren, bevor nachfolgende Berechnungs- oder Evolutionskernel auf diesen Zuständen operieren.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzung:** Die GPU muss vor dem Aufruf dieser Funktion bereits mit einer Initialisierungsfunktion (z.B. `cc_initialize`) initialisiert worden sein.<br />*   **Puffergrößen:** Die Puffer `initial_energy` und `initial_phase` müssen beide eine Länge haben, die dem Parameter `cell_count` entspricht.<br />*   **Lebenszyklus:** Der initialisierte Zustand verbleibt auf der GPU für den angegebenen `gpu_index`, bis die Bibliothek beendet wird. Nachfolgende `subqg`-Funktionen für dieselbe GPU operieren auf diesem Zustand.<br />*   **Fehlercodes:** Ein Rückgabewert von `0` signalisiert Erfolg. Negative Werte deuten auf einen Fehler hin (z. B. ungültiger `gpu_index`, Fehler bei der Speicherzuweisung auf der GPU).<br /><br />#### Hinweis zur ctypes-Anbindung<br /><br />Im ctypes-Beispielcode müssen Sie die Platzhalter für Zeiger und Längen anpassen. Übergeben Sie Zeiger auf die Datenpuffer Ihrer `initial_energy`- und `initial_phase`-Arrays (z. B. aus NumPy) und setzen Sie `cell_count` auf deren Länge.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int subqg_initialize_state_batched(int gpu_index, int cell_count,
                                             const float* initial_energy, const float* initial_phase,
                                             float noise_level, float threshold);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for subqg_initialize_state_batched
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.subqg_initialize_state_batched.argtypes = [c_int, c_int, POINTER(c_float), POINTER(c_float), c_float, c_float]
lib.subqg_initialize_state_batched.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.subqg_initialize_state_batched(0, 0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0.0, 0.0)

print(f"Call to 'subqg_initialize_state_batched' returned: {result}")</code></pre>
      </section>
    
      <section id="subqg_inject_agents">
        <h2>subqg_inject_agents()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>const HPIOAgent*</code></td><td><code>agents</code></td></tr><tr><td><code>int</code></td><td><code>count</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `subqg_inject_agents`<br /><br />#### Kurzbeschreibung<br /><br />Diese Funktion überträgt eine Liste von Agenten-Daten vom Host (CPU) in den internen Zustand des Sub-Quantum-Graphen (subqg) auf der GPU. Sie wird verwendet, um den Graphen zu initialisieren oder den Zustand der Agenten während einer Simulation zu aktualisieren. Die Operation wird in die Befehlswarteschlange der GPU eingereiht und asynchron ausgeführt.<br /><br />#### Anwendungshinweise<br /><br />-   Die Ziel-GPU muss zuvor mit `init_opencl` initialisiert worden sein.<br />-   Ein Sub-Quantum-Graph muss auf der GPU bereits konfiguriert sein, bevor Agenten injiziert werden können.<br />-   Der Parameter `agents` muss auf ein Array mit `count` Elementen vom Typ `HPIOAgent` zeigen.<br />-   Der Aufrufer ist für die Allokierung und Freigabe des `agents`-Speichers auf dem Host verantwortlich.<br />-   Die Funktion überschreibt die vorhandenen Agenten-Daten auf der GPU vollständig mit den neuen Daten.<br />-   Gibt `0` bei Erfolg zurück. Ein negativer Wert deutet auf einen Fehler hin (z.B. ungültiger Index, Fehler bei der Speicherübertragung).<br /><br />#### Python `ctypes` Anbindung<br /><br />Ersetzen Sie im `ctypes`-Code-Snippet den `agents`-Platzhalter durch einen Zeiger auf das Array der `HPIOAgent`-Strukturen und den `count`-Parameter durch die Anzahl der Elemente in diesem Array.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int subqg_inject_agents(int gpu_index, const HPIOAgent* agents, int count);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for subqg_inject_agents
from ctypes import *
from pathlib import Path

class HPIOAgent(Structure):
    _fields_ = [
        ('x', c_float),
        ('y', c_float),
        ('energy', c_float),
        ('coupling', c_float)
    ]

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.subqg_inject_agents.argtypes = [c_int, c_void_p, c_int]
lib.subqg_inject_agents.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.subqg_inject_agents(0, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'subqg_inject_agents' returned: {result}")</code></pre>
      </section>
    
      <section id="subqg_release_state">
        <h2>subqg_release_state()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>void</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `subqg_release_state`<br /><br />#### Beschreibung<br /><br />Diese Funktion gibt alle OpenCL-Speicherressourcen frei, die zuvor für den Quantenzustand auf einem bestimmten GPU-Gerät zugewiesen wurden. Rufen Sie diese Funktion auf, wenn der Zustand nicht mehr benötigt wird, um Speicherlecks auf dem GPU-Gerät zu verhindern. Dies ist der letzte Schritt im Lebenszyklus eines Quantenzustands.<br /><br />#### Anwendungshinweise<br /><br />*   **Voraussetzung:** `subqg_init_state` muss zuvor für denselben `gpu_index` erfolgreich aufgerufen worden sein.<br />*   **Lebenszyklus:** Nach dem Aufruf dieser Funktion sind die Zustandsdaten auf der GPU ungültig und alle zugehörigen Handles sind freigegeben.<br />*   **Geräte-Index:** Der `gpu_index` muss einem gültigen, initialisierten Gerät entsprechen.<br />*   **Fehlerbehandlung:** Die Funktion gibt keinen Status- oder Fehlercode zurück. Die Verantwortung für die korrekte Aufrufreihenfolge liegt beim Aufrufer.<br />*   **Ressourcen:** Gibt die internen OpenCL-Speicherpuffer (`cl_mem`) frei, die den Zustand des Quantensystems repräsentieren.<br /><br />#### Ctypes-Beispiel<br /><br />Im `ctypes`-Code-Snippet muss der ganzzahlige Wert für `gpu_index` durch den Index des Zielgeräts ersetzt werden. Es sind keine Pointer oder Längenangaben erforderlich.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT void subqg_release_state(int gpu_index);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for subqg_release_state
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.subqg_release_state.argtypes = [c_int]
lib.subqg_release_state.restype = c_void_p

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.subqg_release_state(0)

print(f"Call to 'subqg_release_state' returned: {result}")</code></pre>
      </section>
    
      <section id="subqg_set_deterministic_mode">
        <h2>subqg_set_deterministic_mode()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>void</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>enabled</code></td></tr><tr><td><code>uint64_t</code></td><td><code>seed</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `subqg_set_deterministic_mode`<br /><br />#### Beschreibung<br /><br />Aktiviert oder deaktiviert den deterministischen Modus für die stochastischen `SubQG`-Kernel. Wenn aktiviert, erzeugen die Operationen bei gleichem Seed reproduzierbare Ergebnisse. Dies ist entscheidend für das Debugging und die Sicherstellung konsistenter Resultate bei Experimenten.<br /><br />#### Anwendungshinweise<br /><br />*   Die Funktion muss vor der Ausführung von `SubQG`-Kerneln aufgerufen werden, die vom internen Zufallszahlengenerator abhängen.<br />*   Ein Wert von `1` für `enabled` aktiviert den deterministischen Modus, `0` deaktiviert ihn und stellt das Standardverhalten (stochastisch) wieder her.<br />*   Der `seed` wird nur verwendet, wenn `enabled` auf `1` gesetzt ist.<br />*   Die Einstellung ist global für den OpenCL-Kontext und bleibt für alle nachfolgenden `SubQG`-Kernelaufrufe aktiv, bis sie explizit geändert wird.<br />*   Die Funktion gibt keinen Fehlercode zurück; es wird von gültigen Parametern ausgegangen.<br /><br />#### Python ctypes-Integration<br /><br />Stellen Sie im Python-ctypes-Code sicher, dass die Argumenttypen (`argtypes`) der C-Funktionssignatur entsprechen: `ctypes.c_int` für `enabled` und `ctypes.c_uint64` für `seed`.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT void subqg_set_deterministic_mode(int enabled, uint64_t seed);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for subqg_set_deterministic_mode
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.subqg_set_deterministic_mode.argtypes = [c_int, c_uint64]
lib.subqg_set_deterministic_mode.restype = c_void_p

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.subqg_set_deterministic_mode(0, 0)

print(f"Call to 'subqg_set_deterministic_mode' returned: {result}")</code></pre>
      </section>
    
      <section id="subqg_simulation_step">
        <h2>subqg_simulation_step()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>float</code></td><td><code>rng_energy</code></td></tr><tr><td><code>float</code></td><td><code>rng_phase</code></td></tr><tr><td><code>float</code></td><td><code>rng_spin</code></td></tr><tr><td><code>float*</code></td><td><code>out_energy</code></td></tr><tr><td><code>float*</code></td><td><code>out_phase</code></td></tr><tr><td><code>float*</code></td><td><code>out_interference</code></td></tr><tr><td><code>int*</code></td><td><code>out_node_flag</code></td></tr><tr><td><code>int*</code></td><td><code>out_spin</code></td></tr><tr><td><code>int*</code></td><td><code>out_topology</code></td></tr><tr><td><code>float*</code></td><td><code>out_field_map</code></td></tr><tr><td><code>int</code></td><td><code>field_map_length</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `subqg_simulation_step`<br /><br />#### Kurzbeschreibung<br /><br />Führt einen einzelnen Simulationsschritt eines subquantengraph-basierten Modells auf der angegebenen GPU aus. Die Funktion aktualisiert den Zustand des Systems basierend auf den bereitgestellten Zufallswerten für Energie, Phase und Spin. Sie wird typischerweise iterativ in einer Schleife aufgerufen, um die zeitliche Entwicklung des simulierten Systems zu untersuchen.<br /><br />#### Hinweise zur Verwendung<br /><br />*   Die GPU muss vor dem Aufruf dieser Funktion mit `initialize_opencl` initialisiert worden sein.<br />*   Alle `out_*`-Zeiger müssen auf vorab zugewiesene Speicherpuffer der korrekten Größe zeigen.<br />*   Die Größe der Puffer `out_energy`, `out_phase`, `out_interference`, `out_node_flag`, `out_spin` und `out_topology` wird durch die interne Systemkonfiguration bestimmt und ist fest. Die Länge von `out_field_map` muss explizit über `field_map_length` übergeben werden.<br />*   Die `rng_`-Parameter dienen als Eingangswerte für den stochastischen Teil des Simulationsschritts.<br />*   Die Funktion gibt `0` bei Erfolg und einen negativen Fehlercode bei einem Fehler zurück (z. B. ungültiger `gpu_index` oder OpenCL-Kernel-Fehler).<br /><br />#### Python ctypes-Beispiel<br /><br />Im Python `ctypes`-Code-Snippet müssen die Zeiger für alle `out_*`-Parameter (z.B. mit `numpy.ctypeslib.as_ctypes`) und der Wert für `field_map_length` entsprechend der Größe des `out_field_map`-Puffers korrekt gesetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int subqg_simulation_step(int gpu_index, float rng_energy, float rng_phase, float rng_spin,
                                    float* out_energy, float* out_phase, float* out_interference,
                                    int* out_node_flag, int* out_spin, int* out_topology,
                                    float* out_field_map, int field_map_length);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for subqg_simulation_step
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.subqg_simulation_step.argtypes = [c_int, c_float, c_float, c_float, POINTER(c_float), POINTER(c_float), POINTER(c_float), POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_float), c_int]
lib.subqg_simulation_step.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.subqg_simulation_step(0, 0.0, 0.0, 0.0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'subqg_simulation_step' returned: {result}")</code></pre>
      </section>
    
      <section id="subqg_simulation_step_batched">
        <h2>subqg_simulation_step_batched()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>kernel.quantum</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>const float*</code></td><td><code>rng_energy</code></td></tr><tr><td><code>const float*</code></td><td><code>rng_phase</code></td></tr><tr><td><code>const float*</code></td><td><code>rng_spin</code></td></tr><tr><td><code>int</code></td><td><code>batch_count</code></td></tr><tr><td><code>float*</code></td><td><code>out_energy</code></td></tr><tr><td><code>float*</code></td><td><code>out_phase</code></td></tr><tr><td><code>float*</code></td><td><code>out_interference</code></td></tr><tr><td><code>int*</code></td><td><code>out_node_flag</code></td></tr><tr><td><code>int*</code></td><td><code>out_spin</code></td></tr><tr><td><code>int*</code></td><td><code>out_topology</code></td></tr><tr><td><code>float*</code></td><td><code>out_field_map</code></td></tr><tr><td><code>int</code></td><td><code>field_map_length</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `subqg_simulation_step_batched`<br /><br />#### Kurzbeschreibung<br /><br />Führt einen einzelnen, gebündelten Simulationsschritt für ein SubQG-Quantenmodell auf der GPU aus. Die Funktion nutzt Zufallszahlen als Eingabe, um den Zustand (z.B. Energie, Phase, Topologie) für eine Menge von `batch_count` unabhängigen Simulationen zu berechnen. Sie ist für den Einsatz in einer iterativen Schleife konzipiert, um Simulationen in großem Maßstab parallel zu verarbeiten.<br /><br />#### Anwendungshinweise<br /><br />*   Die OpenCL-Umgebung muss vor dem Aufruf dieser Funktion mit `init_opencl` initialisiert worden sein.<br />*   Alle `rng_*` Eingabepuffer sowie die `out_*` Ausgabepuffer (außer `out_field_map`) müssen eine Länge von mindestens `batch_count` haben.<br />*   Die Größe des `out_field_map`-Puffers muss exakt `field_map_length` sein. Dieser Wert entspricht typischerweise `batch_count * <Größe der Feldkarte pro Simulation>`.<br />*   Der Aufrufer ist für die Allokierung und Freigabe aller Ein- und Ausgabepuffer verantwortlich.<br />*   Die Funktion gibt `0` bei Erfolg zurück, andernfalls einen Fehlercode ungleich null.<br /><br />#### Python `ctypes`-Integration<br /><br />In einem Python `ctypes`-Wrapper müssen die Platzhalter für Puffer durch die entsprechenden Pointer auf die Daten (z.B. über `numpy.ctypeslib.as_ctypes`) und die Längenvariablen (`batch_count`, `field_map_length`) durch die korrekten Integer-Werte ersetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int subqg_simulation_step_batched(int gpu_index,
                                            const float* rng_energy, const float* rng_phase, const float* rng_spin,
                                            int batch_count,
                                            float* out_energy, float* out_phase, float* out_interference,
                                            int* out_node_flag, int* out_spin, int* out_topology,
                                            float* out_field_map, int field_map_length);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for subqg_simulation_step_batched
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.subqg_simulation_step_batched.argtypes = [c_int, POINTER(c_float), POINTER(c_float), POINTER(c_float), c_int, POINTER(c_float), POINTER(c_float), POINTER(c_float), POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_float), c_int]
lib.subqg_simulation_step_batched.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.subqg_simulation_step_batched(0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, None  # TODO: provide a valid pointer/buffer, 0)

print(f"Call to 'subqg_simulation_step_batched' returned: {result}")</code></pre>
      </section>
    
      <section id="write_host_to_gpu_blocking">
        <h2>write_host_to_gpu_blocking()</h2>
        <div class="metadata">
          <span><strong>File:</strong> <code>CipherCore_OpenCl.c</code></span>
          <span><strong>Group:</strong> <code>transfer</code></span>
          <span><strong>Returns:</strong> <code>int</code></span>
        </div>
        <h3>Parameters</h3>
        <table><thead><tr><th>Type</th><th>Name</th></tr></thead><tbody>
        <tr><td><code>int</code></td><td><code>gpu_index</code></td></tr><tr><td><code>void*</code></td><td><code>gpu_buffer_handle</code></td></tr><tr><td><code>size_t</code></td><td><code>offset</code></td></tr><tr><td><code>size_t</code></td><td><code>size</code></td></tr><tr><td><code>const void*</code></td><td><code>host_source_ptr</code></td></tr>
      </tbody></table>
        <h3>Description</h3>
        <div class="prose">### `write_host_to_gpu_blocking`<br /><br />#### Beschreibung<br />Überträgt Daten blockierend (synchron) vom Host-Speicher (CPU) in einen bereits existierenden GPU-Puffer. Diese Funktion wird typischerweise genutzt, um Eingabedaten oder Parameter auf die GPU zu laden, bevor eine Kernel-Ausführung beginnt. Der Aufruf kehrt erst zurück, wenn die Übertragung abgeschlossen ist, was die Datensynchronisation sicherstellt.<br /><br />#### Anwendungshinweise<br />- Der GPU-Zielpuffer (`gpu_buffer_handle`) muss vor diesem Aufruf mit `create_gpu_buffer` allokiert worden sein.<br />- Der Host-Quellpuffer (`host_source_ptr`) muss mindestens `size` Bytes groß und lesbar sein.<br />- Die Summe aus `offset` und `size` darf die Gesamtgröße des allokierten GPU-Puffers nicht überschreiten.<br />- Gibt `0` bei Erfolg und einen negativen Fehlercode bei Misserfolg zurück (z. B. bei ungültigen Handles oder Größenangaben).<br /><br />In einem Python `ctypes`-Beispiel müssen der Zeiger auf die Host-Daten (z.B. von einem NumPy-Array), die Datenmenge in Bytes (`size`) und das GPU-Puffer-Handle entsprechend ersetzt werden.</div>
        <h3>Original Prototype</h3>
        <pre><code>DLLEXPORT int write_host_to_gpu_blocking(int gpu_index, void* gpu_buffer_handle, size_t offset, size_t size, const void* host_source_ptr);</code></pre>
        <h3>ctypes Example</h3>
        <pre><code># Auto-generated ctypes snippet for write_host_to_gpu_blocking
from ctypes import *
from pathlib import Path

# (No structs needed for this function)

# Ensure the DLL path is correct for your system
dll_path = Path(r"CipherCore_OpenCl.dll")
lib = cdll.LoadLibrary(str(dll_path))

# Define function signature
lib.write_host_to_gpu_blocking.argtypes = [c_int, c_void_p, c_size_t, c_size_t, c_void_p]
lib.write_host_to_gpu_blocking.restype = c_int

# Example call with placeholder values
# TODO: Replace placeholders with actual data
result = lib.write_host_to_gpu_blocking(0, None  # TODO: provide a valid pointer/buffer, 0, 0, None  # TODO: provide a valid pointer/buffer)

print(f"Call to 'write_host_to_gpu_blocking' returned: {result}")</code></pre>
      </section>
    
    </main>
  
      </div>
    </body>
    </html>
  